# C++新八股文

## 面向对象基础

#### C++面向对象的三大特性

**封装**：隐藏实现细节，实现模块化。控制访问权限，private仅对自己和友元开放，protected开放给子类，public开放给所有对象。

**继承**：无需修改原有类的情况下实现对功能的扩展。存在三种继承，即private继承，protected继承和public继承，解决基类在子类中最高权限的问题(即基类中是public，子类中为private，则权限在子类中修改为private级别，也可以使用using去修改权限)，还可以做多继承和接口继承。

**多态**：一个接口多种形态，通过实现接口重用增加可扩展性。分为静态多态和动态多态。

- 静态多态：发生在编译期,主要包括函数重载和模板。
- 动态多态：发生在运行期,通过虚函数实现。基类中将成员函数声明为 `virtual`, 派生类重写该函数, 并通过基类指针或引用调用, 这样在运行时会根据对象的实际类型选择调用哪个版本。

#### C++多态的实现

C++ 多态分为静态多态和动态多态。

**静态多态**发生在编译期,主要包括函数重载和模板。  

- 函数重载: 同一作用域下,函数名相同,参数列表不同,编译器在编译期根据实参类型/数量选择合适的重载版本。  
- 函数模板: 使用类型参数编写一份通用代码,编译器在编译期根据实参类型对模板进行实例化,生成不同的函数实现。

**动态多态**发生在运行期,通过虚函数实现。基类中将成员函数声明为 `virtual`, 派生类重写该函数, 并通过基类指针或引用调用, 这样在运行时会根据对象的实际类型选择调用哪个版本。

其本质是**晚绑定**:  

- 非虚函数在编译期就确定调用地址(早绑定);  
- 虚函数通过虚函数表(vtable)实现, 对象中有一个虚表指针(vptr), 在构造时初始化, 运行时通过 vptr 在虚表中查找实际要调用的函数地址。

####  C++ 的构造函数能否定义为虚函数？

不能,语法上就不允许给构造函数加 `virtual`。

原因:

- 虚函数依赖虚函数表 (vtable) 和虚表指针 (vptr) 实现运行时多态。vptr 是在对象构造过程中由构造函数负责初始化的,也就是说,***\*对象还没完全构造好之前,就谈“根据动态类型做虚派发”在语义上说不通\****。

- 构造顺序是自上而下: 先调用基类构造函数,再依次调用派生类构造函数。在执行基类构造函数时,对象只能被当作“基类子对象”来看待,此时即使有虚派发,也只会调用基类版本,达不到“根据派生类型选择构造函数”的效果。

因此 C++ 标准直接禁止“虚构造函数”。如果需要“多态创建对象”,通常通过**工厂函数/虚 clone 接口\**等模式来实现。

#### 虚函数和纯虚函数的区别？

- 虚函数: 用 `virtual` 声明，可有默认实现，派生类可选重写，类可实例化。运行时通过基类指针/引用动态绑定到实际类型的函数。

- 纯虚函数: 声明后加 `=0`，无默认实现，强制派生类重写。包含纯虚函数的类是抽象类，不可实例化，用于定义接口规范。

#### 虚析构函数的作用？

**核心作用**: 确保通过基类指针删除派生类对象时，能正确调用派生类析构函数，避免资源泄漏。

原理: 非虚析构时，`delete` 基类指针只调用基类析构函数 → 派生类资源无法释放。虚析构通过动态绑定，保证先调用派生类析构，再调用基类析构。

**适用场景**:

-  多态基类（通过基类指针管理派生类对象）

-  抽象接口类

-  派生类含动态资源

#### 继承下的构造函数和析构函数执行顺序？

**构造顺序**（从上到下）:

1. 基类构造函数
2. 派生类成员对象构造函数（按声明顺序）
3. 派生类自身构造函数

**析构顺序**（与构造相反）:

1. 派生类自身析构函数
2. 派生类成员对象析构函数（按声明逆序）
3. 基类析构函数

**原理**: 确保派生类使用基类资源前，基类已完成初始化；销毁时先释放派生类资源，再释放基类资源。

多继承情况: 按继承列表顺序依次构造基类，析构时逆序。

#### 虚函数表和虚指针的创建时机？

- **虚函数表**: 编译期生成。编译器检测到 `virtual` 关键字时为类生成虚表（函数指针数组）。派生类重写虚函数时更新表中地址。

- **虚指针**: 运行期对象构造时初始化。每个对象独立拥有 vptr，位于对象内存布局起始位置，指向所属类的虚表。

## 内存管理

#### 讲一下循环引用如何发生的，以及如何解决？

对象相互引用时（如双向链表、图结构），会导致引用计数无法归零，资源无法释放。使用weak_ptr打破循环引用，因为它不增加引用计数。

#### shared_ptr是线程安全的吗？多线程中使用智能指针要注意什么？

- 多线程代码操作的是同一个shared_ptr对象是**线程危险**的。

- 多线程代码操作的不是同一个shared_ptr对象，但不同的shared_ptr指向了相同的内存，此时是线程安全的。

#### 何时用shared_ptr，何时用weak_ptr?

**shared_ptr**：需要共享资源所有权时使用。

**weak_ptr**：作为shared_ptr的辅助指针，用于两种场景：

- 打破循环引用

- 需要访问共享资源但不影响其生命周期

#### weak_ptr如何升级为shared_ptr？

weak_ptr 通过 lock() 方法安全升级为 shared_ptr，确保访问对象时其未被销毁。

```c++
std::weak_ptr<A> weak_a = ...;  // 从某处获取 weak_ptr

if (auto shared_a = weak_a.lock()) {  // 尝试升级

  shared_a->do_something();    // 对象存活，安全访问

} else {

  // 对象已销毁，避免悬垂指针

}
```

#### unique指针在编译期如何保证是真的unique？

unique_ptr实现真的unique是靠的以下几个机制：

- **禁用拷贝语义**(核心)：unique_ptr 内部将拷贝构造函数和拷贝赋值运算符声明为 = delete，直接禁止复制行为。
- 仅支持移动语义：unique_ptr 允许通过移动操作转移所有权，转移后原指针变为 nullptr。临时右值可隐式移动。

```c++
std::unique_ptr<int> p3 = std::unique_ptr<int>(new int(10)); // 合法
```

- 编译器的静态检查:类型系统强制约束,如当尝试拷贝时，编译器检查到调用了被删除的函数，直接报错。

#### new和malloc的区别？

- **性质**：new是C++操作符，malloc是C语言函数
- **初始化**：new调用构造函数初始化对象，malloc返回未初始化内存
- **语法**：new无需指定大小（如`new int`），malloc需要（如`malloc(sizeof(int))`）
- **返回类型**：new返回具体类型指针，malloc返回void*需强转
- **错误处理**：new抛出std::bad_alloc异常，malloc返回null
- **配对操作**：new配delete，malloc配free
- **实现**：**malloc**的实现核心是通过操作系统提供的系统调用管理堆内存。使用分配的内存块头部存储元数据，通过链表链接所有空闲块。**new**是C++运算符，其行为包含内存分配和对象构造两阶段，内存分配阶段调用全局operator new函数，默认实现内部调用malloc。对象构造阶段用placement new在已分配内存上调用构造函数。new直接返回响应的数据类型的指针。

#### C++堆和栈的区别？

- 堆：堆上的内存是**动态分配**的，程序在运行时可以根据需要分配和释放内存。堆的大小通常比栈⼤得多，因此可以用于存储较⼤的数据结构和对象。

- 栈：栈上的内存⽣命周期与函数调用相关。局部变量在函数被调用时自动分配内存，函数返回时自动释放内存。栈的大小相对较⼩，适用于存储较⼩的数据结构和对象。

#### 如何让对象只能产生在堆/栈上？

对象产生在堆上：将对象的***\*析构函数设置为私有\****的，因为在栈上分配对象的时候，编译器会自动调用对象的构造函数和析构函数，因此此时如果在栈上分配内存会编译报错，就将内存限制在了只能分配在堆上。

对象产生在栈上：把构造函数禁用，使其无法new对象在堆上。

#### C++指针悬挂问题是什么，如何解决？

指针悬挂：指针指向的内存已被释放或失效，但指针仍保留原地址，访问会引发未定义行为。

**常见场景及解决方法**：

- 指针释放后未置空：释放内存后立即置空指针（`p = nullptr`）
- 返回局部变量地址：避免返回局部对象指针/引用，改用动态分配或静态变量
- 容器内存重分配：容器扩容导致原有元素指针失效，避免长期持有容器元素指针
- 多指针共享同一内存：一个指针释放内存后，其他指针也需置空或使用智能指针

## 关键字与语法

#### C++ 指针和引用的区别？

**引用的本质**：引用是对象的别名,从语义上看“不是一个独立对象”。  
在大多数实现中,编译器会用一个隐藏指针来实现引用,因此它通常占用与指针相同的空间,但这属于实现细节,标准并不强制,一般不在代码中依赖 `sizeof(引用)` 的具体值。

指针与引用的区别:

- 指针本身是一个对象,有自己的地址,可以赋值、拷贝,也可以指向不同的对象,还能为 `nullptr`。
- 引用在定义时**必须初始化**,并且一旦绑定某个对象后就不能再改为引用其他对象,通常也不允许“空引用”。
- 使用指针需要显式解引用 `*p` 访问目标对象;引用则可以像普通变量一样直接使用。
- 语义上,指针适合表示“可选/可变的指向关系”(可以为空、可以重指向),引用适合表示“必须存在的别名”,常用于函数参数和返回值以避免拷贝。

#### override和final关键字的作用？

#### 介绍一下static和const？

**Const**：指定语义约束，告诉编译器对象不能被改变，编译器强制检查。

- 可修饰：普通对象（局部/全局）、函数返回值/参数、指针本身/指针指向对象、类成员变量/函数

**Static**：声明静态成员变量、静态成员函数、静态局部变量、静态全局变量。

- **静态成员**：属于类而非对象，所有对象共享，无需对象即可调用
- **静态局部变量**：函数内声明，程序运行期间只初始化一次
- **静态全局变量**：仅在定义文件内可见，避免命名冲突

#### volatile关键字的作用和适用场景？

**作用**：防止编译器优化，强制每次从内存直接读写变量。不保证线程安全，原子操作推荐用atomic。

**适用场景**：

- 硬件寄存器访问：硬件寄存器的值可能被外部设备随时修改（如传感器、GPIO 状态）
- 中断服务程序（ISR）与主程序共享变量：中断可能异步修改变量（如标志位），主程序需感知最新值
- 多线程环境中的简单标志位：用于线程间通知（如退出标志），但不保证线程安全
- 防止空循环被优化

#### C++ inline内联的作用？

**作用**：将代码复制到调用处，消除函数调用开销，提高性能但会导致代码膨胀。

**C++17新特性**：允许多次定义，不同文件中同名inline函数可实现不同功能（类似static）。

#### explicit关键字是什么作用？

explicit 关键字在 C++ 中用于禁止**编译器进行隐式类型转换**，强制要求开发者显式调用构造函数或转换运算符，提高代码的安全性和可读性。

- 禁止隐式类型转换

- 禁止拷贝初始化

- 防止隐式转换链

#### 什么是左值，什么是右值？如何使用

- 左值⼀般是指向⼀个指定内存的，具有名称的值，它通常拥有⼀个稳定的内存地址，并且有⼀段较长时间的声明周期。左值能取到地址，可多次使用。
- 右值通常是不指向稳定内存地址的匿名值，声明周期很短，通常是暂时的。基于此特性，可以用取地址符来判断，右值不能取到地址，通常为一次性使用的值。

#### 前置++返回的是左值还是右值，后置++呢？字符串字面量呢?

- **前置++**：返回左值（直接对对象自增并返回该对象）

- **后置++**：返回右值（创建临时对象保存原值，对原对象自增后返回临时对象）

- **字符串字面量**：返回左值（存储在数据段，有固定内存地址可取址）

#### class和struct的区别？

- class的默认成员和继承都是**private**的，如果要存储一些内部使用的成员变量推荐使用class,因为内部的一些数据不希望被外部随意获取。

- struct默认是**public**的，如果是要给外部提供一些所需的数据可以使用struct。

#### 引用在声明时是否可以不初始化？

**不可以**。引用必须在声明时立即绑定到一个有效对象，否则编译失败。

如果C++的引用在声明时不立刻绑定一个对象会有以下几种情况发生：

- 编译失败：主流编译器如GCC等规定引用在声明时**必须绑定**到一个已存在的有效对象，如果没有不会生成可执行文件。

- 运行时出现未定义行为：若通过某些方式绕过编译检查，会出现访问一块未知内存地址的情况，会出现崩溃、数据损坏等后果。

- 出现悬空引用：引用绑定到临时对象或已被销毁的对象，然后对象被销毁后会出现悬空的情况

#### C++深拷贝和浅拷贝的区别？

深拷贝和 浅拷贝是对象复制的两种核心机制，主要区别在于对**动态资源**（如堆内存）的处理方式。

- 浅拷贝：仅复制对象的成员变量值，多个对象共享同一块动态内存，易导致悬垂指针、双重释放的问题，性能开销小。

- 深拷贝：复制成员变量值，并为指针指向的资源分配新内存，复制内容。但是需手动实现拷贝构造函数和赋值运算符重载。优点是**资源独立，无共享风险**。

## modern C++特性

### C++11

#### 智能指针有没有了解? 三种智能指针讲一下

智能指针是基于 RAII 封装裸指针的类对象,在构造时获取资源,在析构时自动释放资源,避免忘记 delete、异常路径泄露等问题。

- `shared_ptr` : 共享所有权,内部维护引用计数。每次拷贝计数 +1,销毁或 reset 计数 -1,为 0 时自动释放对象。计数本身是线程安全的,但多线程同时读写同一对象仍需加锁。

- `unique_ptr` : 独占所有权,禁止拷贝,只支持移动。同一时间只能有一个 `unique_ptr` 指向该对象,适合唯一拥有者场景,开销最小。

- `weak_ptr` : 不参与所有权,从 `shared_ptr` 构造,只做“旁观者”。不会增加引用计数,常用于解决 `shared_ptr` 之间的循环引用,需要访问时通过 `lock()` 临时升级为 `shared_ptr`。

Tips: `auto_ptr` 已在 C++11 中废弃, C++17 中移除。

#### shared_ptr引用计数的原理是什么？什么时候增加引用计数，什么时候减少引用计数？

**核心原理**：内部维护计数器跟踪指向资源的shared_ptr数量，计数为0时自动释放资源。

**引用计数增加**：创建新shared_ptr、拷贝构造、拷贝赋值时。

**引用计数减少**：对象析构（离开作用域）、reset()、重新赋值时。

#### 右值引用是如何提高性能的？

右值引用通过**移动语义**和**完美转发**避免不必要的深拷贝，提升性能。

**核心机制**

**1. 移动语义（Move Semantics）**

- 允许"窃取"临时对象的资源（如堆内存、文件句柄），而非拷贝
- 通过移动构造函数和移动赋值运算符实现，将源对象资源的所有权转移到目标对象
- 源对象置为安全的"空状态"（如指针设为nullptr）

**2. 完美转发（Perfect Forwarding）**

- 使用 `std::forward<T>` 保持参数的值类别（左值/右值）不变
- 模板函数中配合万能引用 `T&&` 使用，避免额外的拷贝或移动

#### **右值引用和左值引用的区别？**

**左值引用***：避免拷贝、修改原对象、延长临时对象生命周期（const T&）。

**右值引用*：窃取临时对象资源避免深拷贝、完美转发保持值类别。

#### 移动语义如何使用？

**1. 自动触发**

- 使用临时对象（右值）时编译器自动调用移动构造/移动赋值

```c++
std::string s = "Hello";  // 普通构造
std::string s2 = std::string("World");  // 移动构造（临时对象）
```

**2. 显式调用 std::move**

- 将左值强制转换为右值引用，触发移动语义
- **注意**：移动后源对象处于有效但未指定状态，不应再使用

```c++
std::string s1 = "Hello";
std::string s2 = std::move(s1);  // s1资源转移给s2，s1变空
// s1不应再访问
```

**3. 实现移动构造/赋值函数**

```c++
class MyString {
    char* data;
public:
    // 移动构造函数
    MyString(MyString&& other) noexcept 
        : data(other.data) {
        other.data = nullptr;  // 源对象置空
    }
    
    // 移动赋值运算符
    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;  // 释放自身资源
            data = other.data;  // 窃取资源
            other.data = nullptr;
        }
        return *this;
    }
};
```

关键要点：

- **noexcept 声明**：保证异常安全，STL容器优先使用noexcept的移动操作
- **资源所有权转移**：源对象必须置为安全可析构的状态
- **常见场景**：容器操作、函数返回、智能指针转移

#### 完美转发？

完美转发是 C++11 引入的核心特性，用于在函数模板中无损传递参数的原始值类别（左值/右值）和常量性，避免不必要的拷贝并正确触发移动语义。

- 通用引用：统一接收任意类型的参数

- 引用折叠规则：编译器根据传入参数的类型自动应用折叠规则

- forward语义还原：恢复参数的原始值类别。

#### C++类型推导的作用和用法？

**auto**:变量类型推导。会丢失引用和cv语义，用`auto&`保留。万能引用`auto&&`根据初始值推导左/右值引用。

**decltype**：推导表达式类型，保留所有信息（引用、cv限定符）。

```c++
int a = 10;
decltype(a) b = 20;     // b 为 int
decltype(a + 3.14) c;   // c 为 double[5]
```

#### C++类型推导为什么会有额外的开销？

C++的类型推导有额外开销的原因：

- 1.推导规则复杂：auto会忽略初始化表达式的顶层const、引用和数组退化。需编译器多步分析。decltype的值类别敏感，需根据表达式是变量、函数调用或带括号的左值，分别应用不同规则推导。
- 2.模板实例化负担：在模板中使用auto或decltype推导返回值时，可能触发多次模板实例化。
- 3.意外的值拷贝:若初始化表达式返回引用，但auto未显式声明引用，会进行值拷贝。

#### 使用lambda表达式，捕获局部变量时的规则？

Lambada表达式的捕获规则主要有：值捕获，引用捕获，隐式捕获和显示捕获。

- 值捕获：使用值捕获时，lambda 表达式会复制外部作用域的局部变量，并在lambda 表达式内部使用它们的副本。这意味着捕获的变量在 lambda 表达式创建时就被复制，lambda 表达式内部的操作不会影响原始变量的值。
- 引用捕获：使用引用捕获时，lambda 表达式会获取外部作用域的局部变量的引用。这意味着lambda表达式内部对变量的操作会影响到原始变量。
- 隐式捕获：通过在捕获列表中使用 = 或 & 符号，可以实现隐式捕获。使用= 捕获外部作用域的所有变量的副本，而使用 & 捕获所有变量的引用。
- 显式捕获：在捕获列表中，可以指定要捕获的特定变量，并且可以同时使用值捕获和引用捕获。

#### function,lambda,bind之间的关系？

关系总结：lambda和bind生成可调用对象，function包装它们提供统一接口。

各自**特点**：

- **lambda**：匿名函数对象，可捕获外部变量，直接内联开销小
- **bind**：绑定函数参数，生成新可调用对象，支持参数重排
- **function**：通用包装器，类型擦除，统一存储各种可调用对象

配合使用示例：

```c++
#include <functional>
#include <iostream>
using namespace std;

void print(int a, int b) {
    cout << a + b << endl;
}

int main() {
    // lambda -> function
    function<int(int, int)> f1 = [](int a, int b) { return a + b; };
    cout << f1(1, 2) << endl;  // 3
    
    // bind -> function
    function<void(int)> f2 = bind(print, placeholders::_1, 10);
    f2(5);  // 15
    
    // 直接使用lambda（无类型擦除，性能更好）
    auto f3 = [](int a, int b) { return a * b; };
    cout << f3(3, 4) << endl;  // 12
    
    return 0;
}
```

**选择建议**：

- 优先用lambda（简洁、高效）
- 需要统一类型存储时用function
- bind已被lambda替代，不推荐新代码使用

#### C++函数封装器为什么优于函数指针？

函数封装器的**优点**：

- 函数封装器兼容函数指针，lambda表达式和仿函数，代码更加简洁、清晰且利于拓展。
- 函数封装器类型安全，有严格的类型检查。
- 与现代C++特性的深度集成
- 面向对象支持

### C++14

#### C++14的新特性？

C++14主要是对一些C++11的已有特性做了扩展。

- 支持更灵活的类型推导，C++14支持decltype(auto),这个auto仅仅作为占位符使用。
- constexpr支持更加广泛的语法和应用，如可以使用局部变量。
- 支持更加通用的lambda表达式，允许表达式内部使用auto参数，处理泛型类型更方便。
- 支持返回类型推导

```c++
auto add(int x,int y)//推导出来是int类型的返回值
{
    return x+y;
}
int main()
{
    int num1=1;
    int num2=10;
    int num3=add(num1,num2);
    cout<<num3;
    return 0;
}
```

### C++17

#### C++17的新特性？

- **结构化绑定**：元组/结构体成员绑定到变量

```c++
auto [x, y] = std::make_pair(1, 2);  // x=1, y=2
```

- **if初始化**：if/switch语句中直接初始化变量

```c++
if (int a = getValue(); a > 0) {
    // 使用a
}
```

- **折叠表达式**：简化可变参数模板

```c++
template<typename... Args>
auto sum(Args... args) {
    return (args + ...);  // 展开为 arg1 + arg2 + arg3...
}
```

- **constexpr lambda**：编译时求值的lambda

```c++
constexpr auto add = [](int x, int y) { return x + y; };
constexpr int result = add(3, 4);  // 编译时计算
```

- **std::optional**：安全表示可能无值的对象

```c++
std::optional<int> divide(int a, int b) {
    if (b == 0) return std::nullopt;
    return a / b;
}

if (auto result = divide(10, 2)) {
    std::cout << *result;  // 5
}
```

- **std::variant**：类型安全的联合体
- **std::filesystem**：现代化文件系统API

## 模板与泛化

#### C++中的特化和偏特化是什么？

C++中的模板特化和偏特化是模板编程中用于针对特定类型或条件提供定制化实现的高级技术，旨在**优化性能、处理特殊逻辑或增强类型安全性**。

- 模板特化(全特化)：为模板的所有参数指定具体类型，完全覆盖通用模板的实现。

- 模板偏特化：仅对模板的部分参数进行特化，其余参数保持泛型。

```c++
/*模板全特化和偏特化的例子*/
#include <iostream>
using namespace std;

// 主模板
template <typename T>
class Vector {
private:
    T* data;
    size_t size;

public:
    Vector(size_t s) : size(s) {
        data = new T[size];
    }

    ~Vector() {
        delete[] data;
    }

    void info() {
        cout << "通用Vector" << endl;
    }
};

// 全特化：bool 类型
template <>
class Vector<bool> {
private:
    unsigned char* compressedData; // 使用位压缩存储 bool 数组

public:
    Vector(size_t size) {
        compressedData = new unsigned char[(size + 7) / 8];
    }

    ~Vector() {
        delete[] compressedData;
    }

    void info() {
        cout << "特化BoolVector" << endl;
    }
};

// 偏特化：所有指针类型的 Vector<T*>
template <typename T>
class Vector<T*> {
private:
    T** data;
    size_t size;

public:
    Vector(size_t s) : size(s) {
        data = new T*[size];
    }

    ~Vector() {
        delete[] data;
    }

    void info() {
        cout << "偏特化PointerVector" << endl;
    }
};

int main() {
    Vector<int> v1(10);       // 调用主模板
    v1.info();                // 输出: 通用Vector

    Vector<bool> v2(10);      // 调用全特化
    v2.info();                // 输出: 特化BoolVector

    Vector<int*> v3(10);      // 调用偏特化
    v3.info();                // 输出: 偏特化PointerVector

    return 0;
}
```

#### SFINAE是什么？

SFINAE（Substitution Failure Is Not An Error）：模板参数替换失败时，编译器不报错，而是忽略该模板候选，尝试其他重载。

**应用场景**：

**1. 条件启用模板**

```c++
template <typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
process(T val) { /* 处理整型 */ }

template <typename T>
typename std::enable_if<std::is_floating_point<T>::value, void>::type
process(T val) { /* 处理浮点型 */ }
```

**2. 检测类型成员**

```c++
template <typename, typename = void>
struct has_serialize : std::false_type {};

template <typename T>
struct has_serialize<T, std::void_t<decltype(std::declval<T>().serialize())>> 
    : std::true_type {};
```

**3. 重载决策**

```c++
void process(double val);  // 普通函数优先
template <typename T>
void process(T val);       // 模板备选
```

## STL容器

#### C++的栈容器的内部是什么样的，内存是否连续？

C++的栈stack不是独立容器，是基于其他序列容器的适配器。默认使用deque实现。

**底层容器内存特性**：

- deque：分段连续，由多个固定大小内存块组成，通过中控器管理，逻辑连续但物理不连续

- vector：完全连续，单一大块内存

- list：非连续，双向链表节点分散存储

#### vector与普通数组的区别？vector扩容如何影响复杂度？

**主要区别**：

| 特性         | vector                         | 数组                 |
| ------------ | ------------------------------ | -------------------- |
| **大小**     | 动态，可自动扩容               | 静态，编译时确定     |
| **内存管理** | 自动管理堆内存                 | 栈上分配或手动管理堆 |
| **边界检查** | `at()`有边界检查               | 无边界检查           |
| **功能接口** | 丰富（push_back/size/clear等） | 仅基础操作           |
| **传递方式** | 值语义，可拷贝/移动            | 退化为指针           |

**vector扩容机制与复杂度影响**：

**1. 扩容过程**：

- 容量不足时，分配更大内存（通常是1.5倍或2倍）
- 将原有元素**移动或拷贝**到新内存
- 释放旧内存

**2. 复杂度分析**：

```c++
vector<int> vec;
for (int i = 0; i < n; ++i) {
    vec.push_back(i);  // 平摊O(1)，最坏O(n)
}
```

- **单次push_back**：
  - 无需扩容：O(1)
  - 需要扩容：O(n)（拷贝n个元素）

- **摘销分析**：虽然单次扩容是O(n)，但因为扩容频率低（每次增加2倍），平摊O(1)

**3. 性能优化建议**：

```c++
// 预先分配空间，避免多次扩容
vec.reserve(1000);  // 预留容量

// 或直接指定初始大小
vector<int> vec(1000);  // 初始化1000个元素
```

**4. 频繁扩容的影响**：

- 内存分配/释放开销
- 元素拷贝/移动开销
- 迭代器失效（扩容后所有迭代器、指针、引用均失效）

#### vector的reserve和resize的区别是什么?

vector 的 resize 和 reserve 是两个用于管理容器大小和内存分配的成员函数。它们的区别如下：

- reserve:预留至少 n 个元素的内存空间，但**不创建任何元素**。如果不存在扩容的情况，内存不变化。目的就是为了提前开辟内存空间**提高性能**，避免内存碎片。
- resize：直接改变元素数量，**可能增删元素**。不存在重分配内存的情况。更改容器的大小并调整元素数量，会分配/释放内存和复制/删除元素。

#### deque和vector的区别？内存布局有啥区别？

deque的分段存储:

- 由多个固定大小内存块（通常512字节）组成
- 中控器（指针数组）管理这些块
- 每个块内部连续，块之间不连续

vector的连续存储：

- 所有元素在一块连续内存中

- 支持直接传递首地址给C API

**适用场景**：

**deque**：

- 需要高频头尾操作（队列/双端队列）
- 不需要内存严格连续
- 避免频繁扩容的拷贝开销

**vector**：

- 只在尾部操作
- 需要与C API交互（传递首地址）
- 需要最优随机访问性能
- 内存局部性要求高

#### deque,list,set,multiset,map的对比?

- deque:双向队列实现，存储空间连续，支持随机访问，性能比vector低。适合头尾部频繁操作且需要随机访问的场景。
- list:由双向链表实现，存储空间不连续，只能通过迭代器访问，插入删除效率高，但是每个位置都需要分配额外空间存储前驱元素和后继元素。适用于在**任意位置频繁插入/删除**的场景。
- set:红黑树实现，存储空间不连续，只能通过迭代器访问，适用于有序集合且**元素不重复**的场景。
- multiset:红黑树实现，存储空间不连续，只能通过迭代器访问，默认使用less仿函数进行排序，也可以自定义，适用于有序集合且**元素重复**的场景。
- map:由**红黑树**实现,红黑树是一种平衡二叉搜索树,存储空间**不连续**; 存储的元素是键值对元素。只能通过迭代器进行访问。默认使用less仿函数进行排序，map映射容器不允许重复的键。

#### emplace_back和push_back的区别？

**底层机制对比**：

- push_back：先构造临时对象 → 拷贝/移动到容器 → 销毁临时对象
- emplace_back：直接在容器内存中原地构造，无中间临时对象

**适用场景**：

使用emplace_back：

- 构造复杂对象（多个参数）
- 性能关键场景
- 确保参数类型安全

使用push_back：

- 已有对象实例
- 需要初始化列表：`vec.push_back({1, 2, 3})`
- 代码可读性更重要

#### C++空的class，会主动提供哪些函数？

C++创建了一个空的class，会在特定的情况下提供一些函数。

- 缺省构造函数：声明无参对象时会提供。
- 缺省拷贝构造函数：对象拷贝初始化时候会触发
- 缺省析构函数：对象声明周期结束时会触发
- 缺省赋值运算符：对象复制操作时会触发
- 移动构造函数：对象通过右值初始化触发(C++11)
- 移动赋值运算符：对象通过右值赋值触发(C++11)

## 多线程与并发

#### 对锁有没有了解,介绍一下？

常见 C++ 锁类型:

- `std::mutex`               : 最基本的互斥锁,不可重入。
- `std::recursive_mutex`     : 可重入互斥锁,同一线程可多次加锁。
- `std::timed_mutex`         : 带超时的互斥锁,支持 `try_lock_for/try_lock_until`。
- `std::recursive_timed_mutex`: 可重入 + 支持超时。
- `std::shared_mutex`        : 读写锁,支持多读单写,适合读多写少场景。
- `std::shared_timed_mutex`  : 在 `shared_mutex` 基础上增加超时功能。

#### 进程同步的技术有哪些？

**1. 互斥锁**：同一时刻只有一个进程访问临界区

```c++
std::mutex mtx;
std::lock_guard<std::mutex> lock(mtx);  // RAII自动加锁/解锁
```

**2. 信号量**：计数器控制多进程访问权限

```c++
std::counting_semaphore<10> sem(3);  // 允许3个并发
sem.acquire();  // 获取
sem.release();  // 释放
```

**3. 条件变量**：等待特定条件成立

```c++
std::condition_variable cv;
cv.wait(lock, []{ return data_ready; });  // 等待
cv.notify_one();  // 唤醒
```

**4. 屏障**：多进程同步点等待

```c++
std::barrier sync_point(5);  // 等5个进程
sync_point.arrive_and_wait();  // 同步
```

**5. 原子操作**：不可分割的变量操作

```c++
std::atomic<int> counter(0);
counter.fetch_add(1, std::memory_order_relaxed);
```

**6. 读写锁**：多读单写

```c++
std::shared_mutex rw_mutex;
std::shared_lock lock(rw_mutex);  // 读锁（并发）
std::unique_lock lock(rw_mutex);  // 写锁（独占）
```

#### C++中的原子变量？

原子变量（`std::atomic`）是C++11引入的无锁线程安全工具，保证操作不可分割，避免数据竞争。

**核心特性**：

- **原子性**：操作要么未开始，要么已完成，无中间状态
- **内存序**：控制编译器/CPU乱序执行，保证可见性

**基本用法**：

```c++
#include <atomic>
#include <thread>

std::atomic<int> counter(0);

void increment() {
    for (int i = 0; i < 1000; ++i) {
        counter.fetch_add(1);  // 原子自增
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    t1.join();
    t2.join();
    std::cout << counter.load() << std::endl;  // 2000
}
```

**内存序参数**：

| 内存序                 | 使用场景                         |
| ---------------------- | -------------------------------- |
| `memory_order_relaxed` | 无同步要求，仅保证原子性         |
| `memory_order_acquire` | 读操作，后续读写不可重排到此之前 |
| `memory_order_release` | 写操作，之前读写不可重排到此之后 |
| `memory_order_seq_cst` | 顺序一致（默认），最强同步       |

**底层实现**：

- **x86**：`lock` 前缀指令（`lock add`），锁定总线/缓存行
- **ARM**：LL/SC指令对（`LDREX`/`STREX`），加载链接/存储条件

**适用场景**：

- 计数器、标志位
- 无锁队列/栈
- 双检锁定单例

**注意**：复杂场景（多变量同步）仍需互斥锁。

#### 协程是什么？

C++协程（Coroutine）是C++20引入的一种轻量级并发编程机制，它允许函数在执行过程中暂停（挂起）并在稍后恢复，而无需依赖操作系统线程调度，从而简化异步编程、提高资源利用率。

协程是一种特殊函数，可在执行中主动挂起，保存当前状态（局部变量、执行位置等），后续通过协程句柄恢复执行。
C++20采用**无栈协程模型**，挂起时将上下文（局部变量、寄存器状态）存储在堆上

## 编译与链接

#### 介绍一下RVO？

RVO（Return Value Optimization）是编译器优化技术，在返回对象时直接在调用者的内存位置构造，消除拷贝/移动操作。

RVO分为两种形式：

**1. 纯RVO**

返回无名临时对象。

```c++
MyClass createObject() {
    return MyClass();  // 直接返回临时对象，触发RVO
}
```

**2. NRVO**

返回具名局部对象。

```c++
MyClass createObject() {
    MyClass obj;  // 局部对象
    // ... 一些操作
    return obj;  // 返回具名对象，可能NRVO
}
```

### 内存布局与对齐
