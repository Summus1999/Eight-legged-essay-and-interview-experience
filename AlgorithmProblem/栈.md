# 栈

### leetcode 20  有效的括号

```c++
class Solution {
public:
    bool isValid(string s) {
        /*字符串长度为奇数直接false*/
        if (s.size() % 2) {
            return false;
        }
        /*遍历字符串*/
        stack<char> st;
        for (auto cur : s) {
            if (cur == '(') {
                st.push(')');
            } else if (cur == '[') {
                st.push(']');
            } else if (cur == '{') {
                st.push('}');
            } else {
                /*没有左括号，或者左括号类型不对,返回false*/
                if (st.empty() || st.top() != cur) {
                    return false;
                }
                /*出栈*/
                st.pop();
            }
        }
        return st.empty();
    }
};
```

### leetcode  155  最小栈

```c++
class MinStack {
    stack<pair<int, int>> st;

public:
    /*使用栈存储元素*/
    MinStack() { st.emplace(0, INT_MAX); }
    /*弹栈*/
    void push(int val) { st.emplace(val, min(getMin(), val)); }
    /*入栈*/
    void pop() { st.pop(); }
    /*弹出栈顶*/
    int top() { return st.top().first; }
    /*使用栈存储元素*/
    int getMin() { return st.top().second; }
};

```

### leetcode 739  每日温度

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        /*主要是用单调栈的解法解题*/
        int n = temperatures.size();
        vector<int> ans(n, 0);
        stack<int> st;
        for (int i = n - 1; i >= 0; i--) {
            int currentTemperature = temperatures[i];
            /*弹出所有温度 <= 当前温度的栈顶元素*/
            while (!st.empty() &&
                   currentTemperature >= temperatures[st.top()]) {
                st.pop();
            }
            /*搜索栈顶元素*/
            if (!st.empty()) {
                ans[i] = st.top() - i;
            }
            st.push(i);
        }
        return ans;
    }
};
```

### leetcode  84  柱状图中最大的矩形

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        heights.push_back(-1);
        stack<int> st;
        st.push(-1);
        int ans = 0;
        /*遍历基地*/
        for (int right = 0; right < heights.size(); right++) {
            while (st.size() > 1 && heights[right] <= heights[st.top()]) {
                /*计算矩形面积*/
                int i = st.top();
                st.pop();
                int left = st.top();
                ans = max(ans, heights[i] * (right - left - 1));
            }
            st.push(right);
        }
        return ans;
    }
};
```

### leetcode 394  字符串编码

```c++
class Solution {
public:
    string inputStr;
    int pos;
    /*解析数字*/
    int getDigits() {
        int ret = 0;
        while (pos < inputStr.size() && isdigit(inputStr[pos])) {
            ret = ret * 10 + inputStr[pos] - '0';
            pos++;
        }
        return ret;
    }
    /*解析字符串*/
    string getString() {
        /*异常情况处理*/
        if (pos == inputStr.size() || inputStr[pos] == ']') {
            return "";
        }
        char current = inputStr[pos];
        int repeatTime = 1;
        string ret;
        if (isdigit(current)) {
            repeatTime = getDigits();
            pos++;
            string str = getString();
            pos++;
            while (repeatTime) {
                ret += str;
                repeatTime--;
            }
        } else if (isalpha(current)) {
            /*将当前字符转为字符串*/
            ret = string(1, inputStr[pos]);
            pos++;
        }
        return ret + getString();
    }
    string decodeString(string s) {
        inputStr = s;
        pos = 0;
        return getString();
    }
};
```

### leetcode 232 用栈实现队列

```c++
class MyQueue {
private:
    stack<int> inStack;
    stack<int> outStack;
    /*输入栈元素全部转移到输出栈*/
    void in2out() {
        while (!inStack.empty()) {
            outStack.push(inStack.top());
            inStack.pop();
        }
    }

public:
    MyQueue() {}
    /*入队操作*/
    void push(int x) { inStack.push(x); }
    /*出队操作*/
    int pop() {
        if (outStack.empty()) {
            in2out();
        }
        int x = outStack.top();
        outStack.pop();
        return x;
    }
    /*查看队首元素*/
    int peek() {
        if (outStack.empty()) {
            in2out();
        }
        return outStack.top();
    }

    bool empty() { return inStack.empty() && outStack.empty(); }
};
```

