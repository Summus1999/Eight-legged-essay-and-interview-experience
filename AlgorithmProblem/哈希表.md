# 哈希表

### leetcode 1 两数之和
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        unordered_map<int, int> hash;
        /*使用哈希表来存储已经遍历过的数字及其索引*/
        for (int i = 0; i < n; i++) {
            auto current = nums[i];
            /*查找 target - current 是否在哈希表中*/
            auto it = hash.find(target - current);
            if (it != hash.end()) {
                return {it->second, i};
            }
            hash[current] = i;
        }
        return {};
    }
};
```
### leetcode 30  串联所有单词的子串

```c++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        if (words.empty()) {
            return {};
        }
        int m = words[0].size();
        int n = words.size();
        int windowLength = m * n;
        unordered_map<string, int> target;
        /*统计 words 中每个单词的出现次数*/
        for (auto& w : words) {
            target[w]++;
        }
        vector<int> ans;
        for (int i = 0; i < m; i++) {
            unordered_map<string, int> num;
            int overload = 0;
            for (int right = i + m; right <= s.size(); right += m) {
                /*截取新进入窗口的单词*/
                string in_word = s.substr(right - m, m);
                /*已达目标值，再添加会导致超限*/
                if (num[in_word] == target[in_word]) {
                    overload++;
                }
                num[in_word]++;
                /*计算窗口左边界*/
                int left = right - windowLength;
                if (left < 0) {
                    continue;
                }
                /*overload=0则完全匹配*/
                if (overload == 0) {
                    ans.push_back(left);
                }
                /*移除窗口左侧单词*/
                string out_word = s.substr(left, m);
                num[out_word]--; // 减少计数
                // 若移除后计数回归目标值，超限种类数-1
                if (num[out_word] == target[out_word]) {
                    overload--;
                }
            }
        }
        return ans;
    }
};
```

### leetcode 37  解数独

```c++
class Solution {
private:
    /*递归尝试填充数独棋盘的空格*/
    bool backtracking(vector<vector<char>>& board) {
        /*遍历行列*/
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                if (board[i][j] == '.') {
                    for (char k = '1'; k <= '9'; k++) {
                        if (check(i, j, k, board)) {
                            board[i][j] = k;
                            if (backtracking(board)) {
                                return true;
                            }
                            board[i][j] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
    /*校验函数*/
    bool check(int row, int col, char val, vector<vector<char>>& board) {
        /*检查当前行列是否重复*/
        for (int i = 0; i < 9; i++) {
            if (board[row][i] == val)
                return false;
        }
        for (int j = 0; j < 9; j++) {
            if (board[j][col] == val)
                return false;
        }
        /*检查3x3宫格是否重复*/
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++) {
            for (int j = startCol; j < startCol + 3; j++) {
                if (board[i][j] == val)
                    return false;
            }
        }
        return true;
    }
public:
    /*启动回溯求解*/
    void solveSudoku(vector<vector<char>>& board) { backtracking(board); }
};
```

### leetcode 41 缺失的第一个正数

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int length = nums.size();
        /*遍历 找到元素值与其下标不相配的，交换*/
        for (int i = 0; i < length; i++) {
            while (nums[i] >= 1 && nums[i] <= length &&
                   nums[i] != nums[nums[i] - 1]) {
                int j = nums[i] - 1;
                swap(nums[i], nums[j]);
            }
        }
        /*找第一个位置和元素值不匹配的元素*/
        for (int i = 0; i < length; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return length + 1;
    }
};
```
### leetcode 49 字母异位词分组

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> map;
        /*遍历输入字符串并分组*/
        for (auto s : strs) {
            string sort_s = s;
            sort(sort_s.begin(), sort_s.end());
            map[sort_s].push_back(s);
        }
        /*哈希表转换为结果*/
        vector<vector<string>> result;
        result.reserve(map.size());
        for (auto cur : map) {
            result.push_back(cur.second);
        }
        return result;
    }
};
```

### leetcode 76 最小覆盖子串

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        int length=s.length();
        int ans_left=-1;
        int ans_right=length;
        int hash[128]{};
        int debt=0;
        for(char c:t){
            if(hash[c]==0){
                debt++;
            }
            hash[c]++;
        }
        int left=0;
        for(int right=0;right<length;right++){
            char c=s[right];
            hash[c]--;
            /*如果某个字符hash值为0说明该字符的频率符合要求，debt减1*/
            if(hash[c]==0){
                debt--;
            }
            /*此时字符串符合要求，找最短子串*/
            while(debt==0){
                if(right-left<ans_right-ans_left){
                    ans_left=left;
                    ans_right=right;
                }
                char current=s[left];
                /*左端点字符移出窗口前判断*/
                if(hash[current]==0){
                    debt++;
                }
                hash[current]++;
                left++;
            }
        }
        string answerString;
        if(ans_left<0){
            return "";
        }else{
            answerString=s.substr(ans_left,ans_right-ans_left+1);
            return answerString;
        }

    }
};
```
### leetcode 128 最长连续序列

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int ans = 0;
        /*哈希集合初始化并去重*/
        unordered_set<int> hash(nums.begin(), nums.end());
        for (int left : hash) {
            /*寻找序列起点*/
            if (hash.contains(left - 1)) {
                continue;
            }
            /*寻找序列终点*/
            int right = left + 1;
            while (hash.contains(right)) {
                right++;
            }
            ans = max(ans, right - left);
        }
        /*输出答案*/
        return ans;
    }
};
```

### leetcode  137 只出现一次的数字 II

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int, int> hash;
        /*统计每个数字的出现频率*/
        for (auto cur : nums) {
            hash[cur]++;
        }
        int ans = 0;
        /*遍历哈希表，查找只出现一次的元素*/
        for (auto [num, occ] : hash) {
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
};
```

### leetcode 205 同构字符串

```c++
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        // 双向映射表：s2t 记录 s→t 的映射，t2s 记录 t→s 的映射
        unordered_map<char, char> s2t;
        unordered_map<char, char> t2s;
        int n = s.length();
        for (int i = 0; i < n; i++) {
            auto x = s[i];
            auto y = t[i];
            /*检查冲突*/
            if ((s2t.count(x) && s2t[x] != y) ||
                (t2s.count(y) && t2s[y] != x)) {
                return false;
            }
            /*无冲突时建立双向映射*/
            s2t[x] = y;
            t2s[y] = x;
        }
        return true;
    }
};
```

### leetcode 208  实现Trie

```c++
struct Node {
    Node* son[26]{};
    bool end = false;
};
class Trie {
    Node* root = new Node();
    int find(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) {
                return 0;
            }
            cur = cur->son[c];
        }
        /*走过同样的路（2=完全匹配，1=前缀匹配）*/
        return cur->end ? 2 : 1;
    }

public:
    void insert(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) { // 无路可走？
                cur->son[c] = new Node(); // new 出来！
            }
            cur = cur->son[c];
        }
        cur->end = true;
    }
    bool search(string word) { return find(word) == 2; }
    bool startsWith(string prefix) { return find(prefix) != 0; }
};
```

### leetcode 239  滑动窗口最大值

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> ans; // 存储结果
        deque<int> q;    // 双端队列，存储元素索引（保证对应元素值单调递减）

        for (int i = 0; i < nums.size(); i++) {
            /*维护队列单调性：从队尾移除比当前元素小的索引*/
            while (!q.empty() && nums[q.back()] <= nums[i]) {
                q.pop_back();
            }
            q.push_back(i);
            /*移除超出窗口范围的队首元素*/
            if (!q.empty() && q.front() <= i - k) {
                q.pop_front();
            }
            /*记录当前窗口最大值*/
            if (i >= k - 1) {
                ans.push_back(nums[q.front()]);
            }
        }
        return ans;
    }
};
```

### leetcode 325 和等于K的最长子数组长度

```c++
class Solution {
public:
    int maxSubArrayLen(vector<int>& nums, int k) {
        long long prefixSum = 0;
        int ans = 0;
        int n = nums.size();
        unordered_map<long long, int> hash;
        hash.reserve(n + 1);
        hash.emplace(0, -1);
        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            /*检查是否存在 prefixSum - k,更新最大长度*/
            auto cur = hash.find(prefixSum - k);
            if (cur != hash.end()) {
                ans = max(ans, i - cur->second);
            }
            /*仅记录首次出现的前缀和索引*/
            hash.try_emplace(prefixSum, i);
        }
        return ans;
    }
};
```

### leetcode 347  前K个高频元素

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        /*统计*/
        unordered_map<int, int> hash;
        int maxNum = 0;
        for (int c : nums) {
            hash[c]++;
            maxNum = max(maxNum, hash[c]);
        }
        /*桶处理*/
        vector<vector<int>> buckets(maxNum + 1);
        for (auto& [x, c] : hash) {
            buckets[c].push_back(x);
        }
        /*获取答案*/
        vector<int> ans;
        for (int i = maxNum; i >= 0 && ans.size() < k; i--) {
            ans.insert(ans.end(), buckets[i].begin(), buckets[i].end());
        }
        return ans;
    }
};
```

### leetcode 398 随机数索引

```c++
class Solution {
    /*存储元素值到索引列表的映射*/
    unordered_map<int, vector<int>> pos;

public:
    Solution(vector<int>& nums) {
        /*记录元素索引*/
        for (int i = 0; i < nums.size(); i++) {
            pos[nums[i]].push_back(i);
        }
    }

    int pick(int target) {
        /*获取索引并随机返回*/
        auto& idx = pos[target];
        return idx[rand() % idx.size()];
    }
};
```

### leetcode 438 找到字符串中所有字母异位词

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        /*哈希表+滑动窗口遍历字符串*/
        vector<int> ans;
        unordered_map<char, int> cnt_s;
        unordered_map<char, int> cnt_p;
        for (auto c : p) {
            cnt_p[c]++;
        }
        /*滑动窗口遍历字符串s*/
        for (int right = 0; right < s.size(); right++) {
            cnt_s[s[right]]++;
            int left = right - p.size() + 1;
            /*处理窗口长度不足的情况*/
            if (left < 0) {
                continue;
            }
            if (cnt_p == cnt_s) {
                ans.push_back(left);
            }
            cnt_s[s[left]]--;
            if (cnt_s[s[left]] == 0) {
                cnt_s.erase(s[left]);
            }
        }
        return ans;
    }
};
```
### leetcode 560 和为K的子数组

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int ans = 0;
        int prefix = 0;
        /*哈希表记录前缀和出现的次数，初始化*/
        unordered_map<int, int> hash{{0, 1}};
        /*遍历数组中的每个元素*/
        for (auto current : nums) {
            prefix += current;
            /*检查是否存在prefix - k的前缀和，若存在则说明中间有和为k的子数组*/
            ans += hash.contains(prefix - k) ? hash[prefix - k] : 0;
            hash[prefix]++;
        }
        return ans;
    }
};
```

### leetcode 594  最长和谐子序列

```c++
class Solution {
public:
    int findLHS(vector<int>& nums) {
        /*统计每个数字出现的频率*/
        unordered_map<int, int> hash;
        for (int x : nums) {
            hash[x]++;
        }
        int ans = 0;
        /*遍历频率哈希表，寻找相邻数字组合*/
        for (auto& [x, c] : hash) {
            if (hash.contains(x + 1)) {
                ans = max(ans, c + hash[x + 1]);
            }
        }
        return ans;
    }
};
```

### leetcode 706 设计哈希映射

```c++
class MyHashMap {
private:
    vector<list<pair<int, int>>> data;
    static const int base = 769;
    /*通过取模运算将键映射到桶索引*/
    static int hash(int key) { return key % base; }

public:
    MyHashMap() : data(base) {}

    /*插入或更新键值对*/
    void put(int key, int value) {
        int h = hash(key);
        auto& bucket = data[h];
        for (auto it = bucket.begin(); it != bucket.end(); it++) {
            if (it->first == key) {
                it->second = value;
                return;
            }
        }
        bucket.push_back(make_pair(key, value));
    }
    /** 获取键对应的值，不存在返回 -1 */
    int get(int key) {
        int h = hash(key);
        auto& bucket = data[h];
        for (auto it = bucket.begin(); it != bucket.end(); it++) {
            if (it->first == key) {
                return it->second;
            }
        }
        return -1;
    }
    /** 删除键值对 */
    void remove(int key) {
        int h = hash(key);
        auto& bucket = data[h];
        for (auto it = bucket.begin(); it != bucket.end(); it++) {
            if (it->first == key) {
                bucket.erase(it);
                return;
            }
        }
    }
};
```

### leetcode  12 整数转罗马数字

```c++
class Solution {
    /*静态常量映射表*/
    static constexpr string R[4][10] = {
        {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"},
        {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"},
        {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"},
        {"", "M", "MM", "MMM"}};

public:
    string intToRoman(int num) {
        /*从高位到低位拼接罗马数字*/
        return R[3][num / 1000] + R[2][num / 100 % 10] + R[1][num / 10 % 10] +
               R[0][num % 10];
    }
};
```





