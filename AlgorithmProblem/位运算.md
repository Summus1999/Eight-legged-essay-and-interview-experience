# 位运算

### leetcode 43  字符串相乘

```c++
class Solution {
public:
    string multiply(string num1, string num2) {
        /*边界处理*/
        if (num1 == "0" || num2 == "0") {
            return "0";
        }
        int m = num1.size();
        int n = num2.size();
        vector<int> ansArr(m + n, 0);
        /*逐位相乘并累加*/
        for (int i = m - 1; i >= 0; i--) {
            int x = num1[i] - '0';
            if (x == 0) {
                continue;
            }
            for (int j = n - 1; j >= 0; j--) {
                int y = num2[j] - '0';
                if (y == 0) {
                    continue;
                }
                ansArr[i + j + 1] += x * y;
            }
        }
        /*统一进位*/
        int carry = 0;
        for (int i = m + n - 1; i >= 0; i--) {
            int sum = ansArr[i] + carry;
            carry = sum / 10;
            ansArr[i] = sum % 10;
        }
        /*转换为字符串*/
        string ans;
        int start = 0;
        if (ansArr[0] == 0) {
            start = 1;
        }
        for (int i = start; i < m + n; i++) {
            ans += (ansArr[i] + '0');
        }
        return ans;
    }
};
```

### leetcode  136  只出现一次的数字

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        /*遍历数组中的每个元素,只出现一次的数字会保留*/
        for (auto num : nums) {
            ans ^= num;
        }
        return ans;
    }
};
```

### leetcode 190  颠倒二进制位

```c++
class Solution {
public:
    int reverseBits(int n) {
        int ans = 0;
        for (int i = 0; i < 32 && n > 0; i++) {
            /*最低位反转到最高位并丢弃*/
            ans |= (n & 1) << (31 - i);
            n >>= 1;
        }
        return ans;
    }
};
```

### leetcode 477 汉明距离总和

```c++
class Solution {
public:
    int totalHammingDistance(vector<int>& nums) {
        int ans = 0;
        int n = nums.size();
        for (int i = 0; i < 30; ++i) {
            int numOne = 0;
            /*遍历元素检查*/
            for (auto val : nums) {
                numOne += (val >> i) & 1;
            }
            ans += numOne * (n - numOne);
        }
        return ans;
    }
};
```

