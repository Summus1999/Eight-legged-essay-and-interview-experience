# 图论

### leetcode 200  岛屿数量

```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int ans = 0;
        int m = grid.size();
        int n = grid[0].size();
        /*标记陆地的深度优先搜索*/
        auto dfs = [&](this auto&& dfs, int i, int j) -> void {
            /*边界检查*/
            if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') {
                return;
            }
            /*插旗避免来回横跳，递归搜索*/
            grid[i][j] = '2';
            dfs(i, j - 1);
            dfs(i, j + 1);
            dfs(i - 1, j);
            dfs(i + 1, j);
        };
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                /*发现新岛屿则标记所有陆地*/
                if (grid[i][j] == '1') {
                    dfs(i, j);
                    ans++;
                }
            }
        }
        return ans;
    }
};
```

###  leetcode  994  腐烂的橘子

```c++
class Solution {
    int DIRECTIONS[4][2] = {
        {-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 四个方向（上、下、左、右）

public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        int fresh = 0;
        vector<pair<int, int>> q;
        /*遍历网格，统计新鲜橘子的数量，并将腐烂橘子的位置加入队列*/
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    fresh++; // 统计新鲜橘子个数
                } else if (grid[i][j] == 2) {
                    q.emplace_back(i, j); // 一开始就腐烂的橘子的位置加入队列
                }
            }
        }
        int time = 0;
        while (fresh && !q.empty()) {
            time++;
            vector<pair<int, int>> nxt;
            /*遍历当前已经腐烂的橘子*/
            for (auto& [x, y] : q) {
                for (auto d : DIRECTIONS) {
                    int i = x + d[0];
                    int j = y + d[1];
                    if (0 <= i && i < m && 0 <= j && j < n && grid[i][j] == 1) {
                        fresh--;
                        grid[i][j] = 2;
                        nxt.emplace_back(i, j);
                    }
                }
            }
            /*更新队列为下一轮的腐烂橘子位置*/
            q = move(nxt);
        }
        return fresh ? -1 : time;
    }
};
```

###  leetcode  207  课程表

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        /*构建邻接表，表示每个课程的前置课程*/
        vector<vector<int>> g(numCourses);
        for (auto& p : prerequisites) {
            g[p[1]].push_back(p[0]);
        }
        vector<int> colors(numCourses, 0);
        /*定义一个递归的 DFS 函数，返回 true 表示找到了环*/
        auto dfs = [&](this auto&& dfs, int i) -> bool {
            colors[i] = 1; // 标记 i 正在访问中
            for (int y : g[i]) {
                if (colors[y] == 1 || (colors[y] == 0 && dfs(y))) {
                    return true;
                }
            }
            colors[i] = 2;
            return false;
        };
        /*遍历所有课程，检查是否存在环*/
        for (int i = 0; i < numCourses; i++) {
            if (colors[i] == 0 && dfs(i)) {
                return false;
            }
        }
        return true;
    }
};
```

###  leetcode  208  实现Trie

```c++
struct Node {
    Node* son[26]{};
    bool end = false;
};
class Trie {
    Node* root = new Node();
    int find(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) {
                return 0;
            }
            cur = cur->son[c];
        }
        /*走过同样的路（2=完全匹配，1=前缀匹配）*/
        return cur->end ? 2 : 1;
    }

public:
    void insert(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) { // 无路可走？
                cur->son[c] = new Node(); // new 出来！
            }
            cur = cur->son[c];
        }
        cur->end = true;
    }
    bool search(string word) { return find(word) == 2; }
    bool startsWith(string prefix) { return find(prefix) != 0; }
};
```

