# 排序

## 1.数组+排序

### leetcode 56 合并区间

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        /*按区间起始点排序*/
        ranges::sort(intervals);
        vector<vector<int>> ans;
        for (auto& current : intervals) {
            /*当前区间与结果中最后一个区间重叠*/
            if (!ans.empty() && current[0] <= ans.back()[1]) {
                ans.back()[1] = max(ans.back()[1], current[1]);
            } else {
                /*当前区间无重叠*/
                ans.emplace_back(current);
            }
        }
        return ans;
    }
};
```

### leetcode 215  数组中的第K个最大元素

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        /*排序取倒数第K大的元素即可*/
        ranges::sort(nums);
        int ret = nums[n - k];
        return ret;
    }
};
```

### leetcode 763  划分字母区间

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        /*记录字母最后出现位置*/
        int n = s.size();
        int last[26];
        for (int i = 0; i < n; i++) {
            last[s[i] - 'a'] = i;
        }
        /*遍历字符串并更新区间*/
        vector<int> ans;
        int start = 0;
        int end = 0;
        for (int i = 0; i < n; i++) {
            end = max(end, last[s[i] - 'a']);
            if (end == i) {
                ans.push_back(end - start + 1);
                start = i + 1;
            }
        }
        return ans;
    }
};
```

###  leetcode  169  多数元素

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        /*排序，下标为元素数1/2的必定是多数元素*/
        ranges::sort(nums);
        int target = nums.size() / 2;
        int ret = nums[target];
        return ret;
    }
};
```

### leetcode  1874   两个数组的最小乘积和

```c++
class Solution {
public:
    int minProductSum(vector<int>& nums1, vector<int>& nums2) {
        /*一个升序一个降序排序，遍历搜索即可*/
        ranges::sort(nums1);
        ranges::sort(nums2, greater{});
        int ans = 0;
        for (int i = 0; i < nums1.size(); i++) {
            ans += nums1[i] * nums2[i];
        }
        return ans;
    }
};
```

### leetcode 658  找到K个最接近的元素

```c++
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        /*按离 x 的距离排序，若距离相等则按数值排序*/
        sort(arr.begin(), arr.end(), [x](int a, int b) -> bool {
            return abs(a - x) < abs(b - x) || abs(a - x) == abs(b - x) && a < b;
        });
        /*取前 k 个元素，按数值升序排列*/
        sort(arr.begin(), arr.begin() + k);
        /*返回前 k 个元素*/
        return vector<int>(arr.begin(), arr.begin() + k);
    }
};
```

### leetcode 628  三个数的最大乘积

```c++
class Solution {
public:
    int maximumProduct(vector<int>& nums) {
        /*先排序*/
        ranges::sort(nums);
        int n = nums.size();
        /*两种可能的最大值对比选较大值输出*/
        int num1 = nums[0] * nums[1] * nums[n - 1];
        int num2 = nums[n - 3] * nums[n - 2] * nums[n - 1];
        int ans = max(num1, num2);
        return ans;
    }
};
```

### leetcode 169  多数元素

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        /*排序，下标为元素数1/2的必定是多数元素*/
        ranges::sort(nums);
        int target = nums.size() / 2;
        int ans = nums[target];
        return ans;
    }
};
```







