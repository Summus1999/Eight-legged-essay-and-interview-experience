# 双指针与三指针

### leetcode 3 无重复字符的最长子串

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int length = s.size();
        int ans = 0;
        int left = 0;
        unordered_map<char, int> hash;
        for (int right = 0; right < length; right++) {
            char c = s[right];
            hash[c]++;
            /*如果出现重复字符*/
            while (hash[c] > 1) {
                hash[s[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

### leetcode 11 盛最多水的容器

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        int ans = 0;
        int left = 0;
        int right = n - 1;
        while (left < right) {
            /*计算面积，左右挡板谁矮谁移动，搜最大值*/
            auto area = (right - left) * min(height[left], height[right]);
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
            ans = max(ans, area);
        }
        return ans;
    }
};
```

### leetcode 15 三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        /*预处理排序*/
        ranges::sort(nums);
        int n = nums.size();
        vector<vector<int>> ans;
        /*遍历数组，固定第一个数x*/
        for (int i = 0; i <= n - 3; i++) {
            auto x = nums[i];
            /*剪枝优化*/
            if (i != 0 && x == nums[i - 1]) {
                continue;
            }
            if (x + nums[i + 1] + nums[i + 2] > 0) {
                break;
            }
            if (x + nums[n - 2] + nums[n - 1] < 0) {
                continue;
            }
            /*双指针法：j从i+1开始，k从末尾开始*/
            auto j = i + 1;
            auto k = n - 1;
            while (j < k) {
                auto sum = x + nums[j] + nums[k];
                if (sum > 0) {
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    ans.push_back({x, nums[j], nums[k]});
                    /*剪枝优化*/
                    for (j++; j < k && nums[j] == nums[j - 1]; j++) {
                        continue;
                    }
                    for (k--; j < k && nums[k] == nums[k + 1]; k--) {
                        continue;
                    }
                }
            }
        }
        return ans;
    }
};
```

### leetcode 26 删除有序数组中的重复项

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        /*判空处理*/
        if (nums.empty()) {
            return 0;
        }
        int n = nums.size();
        int left = 1;
        int right = 1;
        while (right < n) {
            /*发现新元素移动指针*/
            if (nums[right - 1] != nums[right]) {
                nums[left] = nums[right];
                left++;
            }
            right++;
        }
        return left;
    }
};
```

### leetcode 27  移除元素

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        /*求出长度，遍历，值为val的元素直接跳过*/
        int n = nums.size();
        int left = 0;
        int right = 0;
        while (right < n) {
            if (nums[right] != val) {
                nums[left] = nums[right];
                left++;
            }
            right++;
        }
        return left;
    }
};
```

### leetcode 32 最长有效括号

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int left = 0;
        int right = 0;
        int n = s.size();
        int ans = 0;
        /*正向扫描（从左到右）*/
        for (int i = 0; i < n; i++) {
            /*统计左 右括号*/
            if (s[i] == '(') {
                left++;
            } else if (s[i] == ')') {
                right++;
            }
            /*左右括号平衡时更新最大长度*/
            if (left == right) {
                ans = max(ans, right * 2);
            } else if (left < right) {
                left = 0;
                right = 0;
            }
        }
        left = 0;
        right = 0;
        /*反向扫描（从右到左）*/
        for (int i = n - 1; i >= 0; i--) {
            /*统计左 右括号*/
            if (s[i] == '(') {
                left++;
            } else if (s[i] == ')') {
                right++;
            }
            /*左右括号平衡时更新最大长度*/
            if (left == right) {
                ans = max(ans, left * 2);
            } else if (left > right) {
                left = 0;
                right = 0;
            }
        }
        return ans;
    }
};
```

### leetcode 34 在排序数组中查找元素的第一个和最后一个位置

```c++
class Solution {
    int lower_bound(vector<int>& nums, int target) {
        int left = -1, right = nums.size();
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid;
            } else {
                left = mid;
            }
        }
        return right;
    }

public:
    vector<int> searchRange(vector<int>& nums, int target) {
        /*查找target的起始位置*/
        int start = lower_bound(nums, target);
        if (start == nums.size() || nums[start] != target) {
            return {-1, -1};
        }
        /*查找target+1的起始位置，减1得到target的结束位*/
        int end = lower_bound(nums, target + 1) - 1;
        /*返回找到的起始和结束位置*/
        return {start, end};
    }
};
```

### leetcode 42 接雨水

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int ret = 0;
        int prefix = 0;
        int suffix = 0;
        /*相向双指针，谁小谁移动，同时计算雨水量即可*/
        while (left < right) {
            prefix = fmax(prefix, height[left]);
            suffix = fmax(suffix, height[right]);
            if (height[left] < height[right]) {
                ret += prefix - height[left];
                left++;
            } else {
                ret += suffix - height[right];
                right--;
            }
        }
        return ret;
    }
};
```

### leetcode 80  删除有序数组中的重复项 II

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        int left = 2;
        for (int right = 2; right < n; right++) {
            /*比较当前元素与新数组倒数第二个元素*/
            if (nums[left - 2] != nums[right]) {
                nums[left] = nums[right];
                left++;
            }
        }
        return min(left, n);
    }
};
```

### leetcode 88  合并两个有序数组

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        /*元素复制到尾部*/
        for (int i = 0; i < n; i++) {
            nums1[m + i] = nums2[i];
        }
        /*排序*/
        ranges::sort(nums1);
    }
};
```

### leetcode  125  验证回文串

```c++
class Solution {
public:
    bool isPalindrome(string s) {
        int left = 0;
        int n = s.size();
        int right = n - 1;
        /*相向双指针解法*/
        while (left <= right) {
            if (!isalnum(s[left])) {
                left++;
            } else if (!isalnum(s[right])) {
                right--;
            } else if (tolower(s[left]) == tolower(s[right])) {
                left++;
                right--;
            } else {
                return false;
            }
        }
        return true;
    }
};
```

### leetcode   165  比较版本号

```c++
class Solution {
private:
    /* 解析下一个版本段并移动指针 */
    int parseNextSegment(string& ver, int& pos, int len) {
        int num = 0;
        /*解析数字直到分隔符或字符串结束*/
        while (pos < len && ver[pos] != '.') {
            num = num * 10 + (ver[pos] - '0');
            pos++;
        }
        /*安全跳过分隔符*/
        if (pos < len && ver[pos] == '.') {
            pos++;
        }
        return num;
    }

public:
    int compareVersion(string version1, string version2) {
        int m = version1.size();
        int n = version2.size();
        int i = 0;
        int j = 0;
        while (i < m || j < n) {
            /*解析当前段值*/
            int num1 = parseNextSegment(version1, i, m);
            int num2 = parseNextSegment(version2, j, n);
            /*比较当前段*/
            if (num1 > num2) {
                return 1;
            }
            if (num1 < num2) {
                return -1;
            }
        }
        return 0;
    }
};
```

###  leetcode 167  两数之和 II - 输入有序数组

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        /*双指针解题，根据题目数组元素非递减解即可*/
        int length = numbers.size();
        int left = 0;
        int right = length - 1;
        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (sum == target) {
                return {left + 1, right + 1};
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
        return {-1, -1};
    }
};
```

### leetcode 283 移动零

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int left = 0;
        for (int right = 0; right < n; right++) {
            /*遇到非0的值直接交换*/
            if (nums[right]) {
                swap(nums[left], nums[right]);
                left++;
            }
        }
    }
};
```

### leetcode  287  寻找重复数

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        /*初始化快慢指针*/
        int slow = nums[0];
        int fast = nums[0];
        /*检测环是否存在*/
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        slow = nums[0];
        /*寻找环的位置*/
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};
```

### leetcode 350   两个数组的交集 II

```c++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        /*构建哈希表并遍历nums1*/
        unordered_map<int, int> hash;
        for (auto cur : nums1) {
            hash[cur]++;
        }
        vector<int> ans;
        for (auto cur : nums2) {
            /*若当前元素在哈希表中存在且计数>0*/
            if (hash[cur] > 0) {
                hash[cur]--;
                ans.push_back(cur);
            }
        }
        return ans;
    }
};
```

### leetcode  392 判断子序列

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int sSize=s.size();
        int tSize=t.size();
        int left=0;
        int right=0;
        while(left<sSize&&right<tSize){
            if(s[left]==t[right]){
                left++;
            }
            right++;
        }
        return left==sSize;
    }
};
```

### leetcode  443  压缩字符串

```c++
class Solution {
public:
    int compress(vector<char>& chars) {
        int pos = 0;
        int slow = 0;
        int n = chars.size();
        /*使用快指针遍历整个字符数组*/
        for (int fast = 0; fast < n; fast++) {
            /*检测连续字符序列结束*/
            if (fast == n - 1 || chars[fast] != chars[fast + 1]) {
                chars[pos] = chars[fast];
                pos++;
                int num = fast - slow + 1;
                if (num > 1) {
                    int anchor = pos;
                    while (num > 0) {
                        chars[pos] = '0' + num % 10;
                        pos++;
                        num /= 10;
                    }
                    reverse(&chars[anchor], &chars[pos]);
                }
                /*更新下一个连续序列的起始位置*/
                slow = fast + 1;
            }
        }
        return pos;
    }
};
```

### leetcode 524  通过删除字母匹配到字典里最长单词

```c++
class Solution {
public:
    string findLongestWord(string s, vector<string>& dictionary) {
        /*优先按长度降序，长度相同时按字典序升序*/
        sort(dictionary.begin(), dictionary.end(), [](string& a, string& b) {
            if (a.size() != b.size()) {
                return a.size() > b.size();
            }
            return a < b;
        });
        /*遍历字典中的每个单词*/
        int m = s.size();
        for (auto& cur : dictionary) {
            int left = 0;
            int right = 0;
            int n = cur.size();
            /*双指针遍历 s 和 cur*/
            while (left < m && right < n) {
                if (s[left] == cur[right]) {
                    right++;
                }
                left++;
            }
            /*如果 cur 的所有字符都匹配成功*/
            if (right == n) {
                return cur;
            }
        }
        return "";
    }
};
```

### leetcode 611  有效三角形的个数

```c++
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        ranges::sort(nums);
        int n = nums.size();
        int ans = 0;
        for (int i = n - 1; i >= 2; i--) {
            int left = 0;
            int right = i - 1;
            /*双指针寻找满足条件的两条较短边*/
            while (left < right) {
                if (nums[left] + nums[right] > nums[i]) {
                    ans += right - left;
                    right--;
                } else {
                    left++;
                }
            }
        }
        return ans;
    }
};
```

### leetcode 633  平方数之和

```c++
class Solution {
public:
    bool judgeSquareSum(int c) {
        /*相向双指针法*/
        int a = 0, b = sqrt(c);
        while (a <= b) {
            if (a * a == c - b * b) {
                return true;
            }
            if (a * a < c - b * b) {
                a++;
            } else {
                b--;
            }
        }
        return false;
    }
};
```

### leetcode 905  按奇偶排序数组

```c++
class Solution {
public:
    vector<int> sortArrayByParity(vector<int>& nums) {
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        while (left < right) {
            /*左指针指向偶数*/
            if (nums[left] % 2 == 0) {
                left++;
            } else if (nums[right] % 2) {
                right--;
            } else {
                /*左指针指向奇数且右指针指向偶数*/
                swap(nums[left], nums[right]);
                left++;
                right--;
            }
        }
        return nums;
    }
};
```

### leetcode 922   按奇偶排序数组 II

```c++
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& nums) {
        int n = nums.size();
        int left = 0;
        int right = 1;
        /*遍历数组*/
        while (left < n) {
            if (nums[left] % 2 == 0) {
                left += 2;
            } else if (nums[right] % 2) {
                right += 2;
            } else {
                swap(nums[left], nums[right]);
                left += 2;
                right += 2;
            }
        }
        return nums;
    }
};
```

### leetcode 1385  两个数组间的距离值

```c++
class Solution {
public:
    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
        ranges::sort(arr1);
        ranges::sort(arr2);
        int m = arr1.size();
        int n = arr2.size();
        int ans = 0;
        int right = 0;
        for (int left = 0; left < m; left++) {
            /*找到第一个 >= arr1[left] - d 的元素*/ 
            while (right < n && arr2[right] < arr1[left] - d) {
                right++;
            }
            /*检查是否不存在任何元素满足 |arr1[left] - arr2[right]| <= d*/ 
            if (right == n || arr2[right] > arr1[left] + d) {
                ans++;
            }
        }
        return ans;
    }
};
```

### leetcode 1446  连续字符

```c++
class Solution {
public:
    int maxPower(string s) {
        int n=s.size();
        int ans = 1;
        int cur = 1;
        /*从第2个字符开始遍历*/
        for (int i = 1; i < n; i++) {
            /*连续则加1，否则重置计数器*/
            if (s[i] == s[i - 1]) {
                cur++;
                ans = max(ans, cur);
            } else {
                cur = 1;
            }
        }
        return ans;
    }
};
```

### leetcode 1471  数组中的 k 个最强值

```C++
class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        /*将数组按升序排序*/
        sort(arr.begin(), arr.end());
        int n = arr.size();
        int median = arr[(n - 1) / 2];
        int left = 0, right = n - 1;
        vector<int> ans;
        ans.reserve(k);
        /*使用双指针策略选择最强的 k 个元素*/
        while (k-- > 0) {
            /*比较左右指针元素与中位数的距离*/
            if (arr[right] - median >= median - arr[left]) {
                ans.push_back(arr[right]);
                right--;
            } else {
                ans.push_back(arr[left]);
                left++;
            }
        }
        return ans;
    }
};
```

### leetcode 1750   删除字符串两端相同字符后的最短长度

```c++
class Solution {
public:
    int minimumLength(string s) {
        int n = s.size();
        int left = 0;
        int right = n - 1;
        while (left < right && s[left] == s[right]) {
            auto cur = s[left];
            /*当首尾字符相等时，删除所有首尾连续的该字符。*/
            while (left <= right && s[left] == cur) {
                left++;
            }
            while (left <= right && s[right] == cur) {
                right--;
            }
        }
        return right - left + 1;
    }
};
```

### leetcode 1793  好子数组的最大分数

```c++
class Solution {
public:
    int maximumScore(vector<int>& nums, int k) {
        int n = nums.size();
        int ans = nums[k];
        int cur = nums[k];
        int left = k;
        int right = k;
        for (int i = 0; i < n - 1; i++) {
            /*选择向左或向右扩展*/
            if (right == n - 1 || (left && nums[left - 1] > nums[right + 1])) {
                left--;
                cur = min(cur, nums[left]);
            } else {
                right++;
                cur = min(cur, nums[right]);
            }
            ans = max(ans, cur * (right - left + 1));
        }
        return ans;
    }
};
```

### leetcode 1855 下标对中的最大距离

```c++
class Solution {
public:
    int maxDistance(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size();
        int n = nums2.size();
        int left = 0;
        int ans = 0;
        for (int right = 0; right < n; right++) {
            /*移动 left 直到 nums1[left] <= nums2[right]*/
            while (left < m && nums1[left] > nums2[right]) {
                left++;
            }
            /*更新最大距离*/
            if (left < m) {
                ans = max(ans, right - left);
            }
        }
        return ans;
    }
};
```

### leetcode  2105  给植物浇水 II

```c++
class Solution {
public:
    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {
        int ans = 0;
        int alice = capacityA;
        int bob = capacityB;
        int left = 0;
        int right = plants.size() - 1;
        while (left < right) {
            /*alice没有足够的水，重新灌满水罐*/
            if (alice < plants[left]) {
                alice = capacityA;
                ans++;
            }
            alice -= plants[left];
            left++;
            /*bob没有足够的水，重新灌满水罐*/
            if (bob < plants[right]) {
                bob = capacityB;
                ans++;
            }
            bob -= plants[right];
            right--;
        }
        /*最后两人剩余的水都不够灌溉任意一人补充后灌溉即可*/
        if (left == right && max(alice, bob) < plants[left]) {
            ans++;
        }
        return ans;
    }
};

```

### leetcode 2109  向字符串添加空格

```c++
class Solution {
public:
    string addSpaces(string s, vector<int>& spaces) {
        string ans;
        int m = s.size();
        int n = spaces.size();
        int left = 0;
        /*遍历原字符串的每个字符*/
        for (int right = 0; right < m; right++) {
            /*找到插入空格的地方*/
            if (left < n && spaces[left] == right) {
                ans += ' ';
                left++;
            }
            /*添加结果*/
            ans += s[right];
        }
        return ans;
    }
};
```

### leetcode 2367  等差三元组的数目

```c++
class Solution {
public:
    int arithmeticTriplets(vector<int>& nums, int diff) {
        int ans = 0;
        int n = nums.size();
        int i = 0;
        int j = 1;
        int k = 2;
        /*遍历所有可能的 k*/
        for (k = 2; k < n; k++) {
            while (i < j && nums[i] < nums[k] - 2 * diff) {
                i++;
            }
            while (j < k && nums[j] < nums[k] - diff) {
                j++;
            }
            /*检查是否同时满足两个等差条件*/
            if (i < j && j < k && nums[j] - nums[i] == diff &&
                nums[k] - nums[j] == diff) {
                ans++;
            }
        }
        return ans;
    }
};
```

### leetcode 2486  追加字符以获得子序列

```c++
class Solution {
public:
    int appendCharacters(string s, string t) {
        int left = 0;
        int m = s.size();
        int n = t.size();
        /*遍历字符串 t 的每个字符*/
        for (int right = 0; right < n; ++right) {
            /*跳过不匹配字符*/
            while (left < m && s[left] != t[right]) {
                left++;
            }
            if (left == m) {
                return n - right;
            }
            left++;
        }
        return 0;
    }
};
```

### leetcode 2540  最小公共值

```c++
class Solution {
public:
    int getCommon(vector<int>& nums1, vector<int>& nums2) {
        int ans;
        int m = nums1.size();
        int n = nums2.size();
        int left = 0;
        int right = 0;
        while (left < m && right < n) {
            if (nums1[left] == nums2[right]) {
                /*找到最小公共值返回结果即可*/
                ans = nums1[left];
                return ans;
            } else if (nums1[left] < nums2[right]) {
                left++;
            } else {
                right++;
            }
        }
        return -1;
    }
};
```

### leetcode 2570  合并两个二维数组

```c++
class Solution {
public:
    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1,
                                    vector<vector<int>>& nums2) {
        map<int, int> mergedMap;
        vector<vector<int>> ans;
        /*遍历 nums1，将键值对存入 map*/
        for (const auto& pair : nums1) {
            int id = pair[0];
            int value = pair[1];
            mergedMap[id] += value; 
        }
        /*遍历 nums2，合并到 map*/
        for (const auto& pair : nums2) {
            int id = pair[0];
            int value = pair[1];
            mergedMap[id] += value; 
        }
        for (const auto& [id, value] : mergedMap) {
            ans.push_back({id, value});
        }
        return ans;
    }
};
```

