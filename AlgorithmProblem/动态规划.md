# 动态规划
### leetcode  70  爬楼梯

```c++
/*解法1*/
class Solution {
public:
    int climbStairs(int n) {
        /*记忆化数组*/
        vector<int> memory(n + 1, 0);
        auto dfs = [&](this auto&& self, int i) -> int {
            /*递归终止*/
            if (i <= 1) {
                return 1;
            }
            /*已计算则直接返回*/
            int& ret = memory[i];
            if (ret) {
                return ret;
            }
            return ret = self(i - 1) + self(i - 2);
        };
        return dfs(n);
    }
};
/*解法2*/
class Solution {
    vector<int> memory;
    /*记忆化*/
    int dfs(int i) {
        if (i <= 1) {
            return 1;
        }
        /*检查是否已计算过当前结果*/
        int& ret = memory[i];
        if (ret) {
            return ret;
        }
        /*递归：爬到第 i 阶 = 爬到第 i-1 阶 + 爬到第 i-2 阶*/
        return ret = dfs(i - 2) + dfs(i - 1);
    }

public:
    int climbStairs(int n) {
        memory.resize(n + 1);
        return dfs(n);
    }
};
```

### leetcode  198  打家劫舍

```c++
/*模板题*/
/*记忆化搜索解法*/
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        /*记忆化数组存储子数组结果*/
        vector<int> memo(n, -1);
        auto dfs = [&](this auto&& dfs, int i) -> int {
            /*无房屋可抢劫，返回0*/
            if (i < 0) {
                return 0;
            }
            /*抢劫过的房屋直接返回结果*/
            if (memo[i] != -1) {
                return memo[i];
            }
            /*计算最大抢劫金额*/
            return memo[i] = max(dfs(i - 1), dfs(i - 2) + nums[i]);
        };
        /*反向遍历房屋*/
        return dfs(n - 1);
    }
};
/*状态压缩解法*/
class Solution {
public:
    int rob(vector<int>& nums) {
        int f0 = 0;
        int f1 = 0;
        // 遍历每个房屋的金额
        for (auto x : nums) {
            /*计算最大收益*/
            int new_f = max(f1, f0 + x);
            /*更新状态*/
            f0 = f1;
            f1 = new_f;
        }
        /*返回最大收益*/
        return f1;
    }
};
```

### leetcode  494 目标和

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        /*计算数组总和*/
        int sum = reduce(nums.begin(), nums.end()) - abs(target);
        /*边界检查*/
        if (sum < 0 || sum % 2) {
            return 0;
        }
        int capacity = sum / 2;
        vector<int> dp(capacity + 1, 0);
        dp[0] = 1;
        for (auto num : nums) {
            /*倒序遍历背包容量*/
            for (int cur = capacity; cur >= num; cur--) {
                dp[cur] += dp[cur - num];
            }
        }
        return dp[capacity];
    }
};
```

### leetcode  322  零钱兑换

```c++
/*记忆化搜索解法*/
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        /*记忆化数组并初始化*/
        vector memo(n, vector<int>(amount + 1, -1));
        auto dfs = [&](this auto&& dfs, int coinNum, int remainCoin) -> int {
            /*硬币用尽*/
            if (coinNum < 0) {
                return remainCoin == 0 ? 0 : INT_MAX / 2;
            }
            /*当前硬币面值大于剩余金额：无法使用该硬币*/
            int& res = memo[coinNum][remainCoin];
            if (res != -1) {
                return res;
            }
            /*核心决策*/
            if (remainCoin < coins[coinNum]) {
                return res = dfs(coinNum - 1, remainCoin);
            }
            return res = min(dfs(coinNum - 1, remainCoin),
                             dfs(coinNum, remainCoin - coins[coinNum]) + 1);
        };
        int ans = dfs(n - 1, amount);
        return ans < INT_MAX / 2 ? ans : -1;
    }
};
/*完全背包解法*/
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dpTable(amount + 1, INT_MAX / 2);
        dpTable[0] = 0;
        for (auto coin : coins) {
            /*从当前硬币面值开始，更新到目标金额的状态*/
            for (int cur = coin; cur <= amount; cur++) {
                /*是否使用当前硬币可减少硬币数量*/
                dpTable[cur] = min(dpTable[cur], dpTable[cur - coin] + 1);
            }
        }
        int minCoins = dpTable[amount];
        return minCoins < INT_MAX / 2 ? minCoins : -1;
    }
};
```



### leetcode   1143   最长公共子序列

```c++
/*记忆化搜索解法*/
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        vector memo(m, vector<int>(n, -1));
        /*递归搜索 + 保存计算结果 = 记忆化搜索*/
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0 || j < 0) {
                return 0;
            }
            int& ret = memo[i][j];
            if (ret != -1) {
                return ret;
            }
            if (text1[i] == text2[j]) {
                return ret = dfs(i - 1, j - 1) + 1;
            }
            return ret = max(dfs(i - 1, j), dfs(i, j - 1));
        };
        return dfs(m - 1, n - 1);
    }
};
/*线性DP解法*/
class Solution {
public:
    int longestCommonSubsequence(string s, string t) {
        int m = t.size();
        vector<int> dp(m + 1, 0);
        for (auto cur : s) {
            int pre = dp[0];
            for (int j = 0; j < m; j++) {
                int tmp = dp[j + 1];
                /*字符匹配时取左上角值+1，否则取上方或左方最大值*/
                if (cur == t[j]) {
                    dp[j + 1] = pre + 1;
                } else {
                    dp[j + 1] = max(dp[j + 1], dp[j]);
                }
                /*更新pre*/
                pre = tmp;
            }
        }
        return dp[m];
    }
};
```

### leetcode   72   编辑距离

```c++
/*记忆化搜索解法*/
class Solution {
public:
    int minDistance(string word1, string word2) {
        /*递归搜索 + 保存计算结果 = 记忆化搜索*/
        int m = word1.size();
        int n = word2.size();
        vector memo(m, vector<int>(n, -1));
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0) {
                return j + 1;
            }
            if (j < 0) {
                return i + 1;
            }
            int& ret = memo[i][j];
            if (ret != -1) {
                return ret;
            }
            if (word1[i] == word2[j]) {
                return ret = dfs(i - 1, j - 1);
            }
            return ret = min({dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1)}) + 1;
        };
        return dfs(m - 1, n - 1);
    }
};
/*线性DP解法*/
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word2.size();
        vector<int> dp(m + 1, 0);
        /*初始化*/
        for (int j = 0; j < m; j++) {
            dp[j + 1] = j + 1;
        }
        for (auto cur : word1) {
            int pre = dp[0];
            dp[0]++;
            for (int j = 0; j < m; j++) {
                int tmp = dp[j + 1];
                if (cur == word2[j]) {
                    dp[j + 1] = pre;
                } else {
                    dp[j + 1] = min({dp[j + 1], dp[j], pre}) + 1;
                }
                pre = tmp;
            }
        }
        return dp[m];
    }
};
```

### leetcode 300 最长递增子序列

```c++
/*贪心+二分解法*/
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        auto end = nums.begin();
        for (auto cur : nums) {
            /*查找第一个 >= cur 的位置*/
            auto it = lower_bound(nums.begin(), end, cur);
            *it = cur;
            /*若插入位置是序列末尾，则扩展序列长度*/
            if (it == end) {
                end++;
            }
        }
        return end - nums.begin();
    }
};
```

### leetcode  122 买卖股票的最佳时机 II

```c++
/*状态机DP解法*/
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        /*初始化当前现金和当前利润*/
        int cash = 0;
        int curProfit = INT_MIN;
        for (auto cur : prices) {
            /*更新现金，更新当前利润并同步状态*/
            int new_f = max(cash, curProfit + cur);
            curProfit = max(curProfit, cash - cur);
            cash = new_f;
        }
        return cash;
    }
};
```

### leetcode 309  买卖股票的最佳时机含冷冻期

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int preMaxProfit = 0;
        int cash = 0;
        int curProfit = INT_MIN;
        for (auto cur : prices) {
            /*更新现金和当前利润状态*/
            int newCash = max(cash, curProfit + cur);
            curProfit = max(curProfit, preMaxProfit - cur);
            /*滚动更新状态，与不带冷冻期比多更新一个2天前利润*/
            preMaxProfit = cash;
            cash = newCash;
        }
        return cash;
    }
};
```

### leetcode  188  买卖股票的最佳时机 IV

```c++
/*状态机DP解法*/
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<array<int, 2>> f(k + 2, {INT_MIN / 2, INT_MIN / 2});
        for (int j = 1; j <= k + 1; j++) {
            f[j][0] = 0;
        }
        for (auto cur : prices) {
            for (int j = k + 1; j > 0; j--) {
                /*更新不持有股票的状态*/
                f[j][0] = max(f[j][0], f[j][1] + cur);
                /*更新持有股票的状态*/
                f[j][1] = max(f[j][1], f[j - 1][0] - cur);
            }
        }
        return f[k + 1][0];
    }
};
```

### leetcode 516 最长回文子序列

```c++
/*区间DP解法*/
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<int> dp(n, 1);
        for (int i = n - 1; i >= 0; i--) {
            int pre = 0;
            for (int j = i + 1; j < n; j++) {
                int tmp = dp[j];
                /*状态转移：两端相等则+2，否则继承左右子串最大值*/
                if (s[i] == s[j]) {
                    dp[j] = pre + 2;
                } else {
                    dp[j] = max(dp[j], dp[j - 1]);
                }
                /*更新pre为下一轮准备*/
                pre = tmp;
            }
        }
        return dp[n - 1];
    }
};
```

### leetcode 1039   多边形三角剖分的最低得分

```c++
/*区间DP解法*/
class Solution {
public:
    int minScoreTriangulation(vector<int>& values) {
        int n = values.size();
        vector<vector<int>> f(n, vector<int>(n, 0));
        /*逆序遍历起点*/
        for (int i = n - 3; i >= 0; i--) {
            for (int j = i + 2; j < n; j++) {
                f[i][j] = INT_MAX;
                for (int k = i + 1; k < j; k++) {
                    /*状态转移方程*/
                    f[i][j] =
                        min(f[i][j], f[i][k] + f[k][j] +
                                         values[i] * values[j] * values[k]);
                }
            }
        }
        return f[0][n - 1];
    }
};
```

### leetcode 53 最大子数组和

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int current_prefix = 0;
        int min_prefix = 0;
        int ans = INT_MIN;
        /*遍历nums，求当前前缀和-历史前缀和的MAX，类似买卖股票最佳时机I*/
        for (int i = 0; i < nums.size(); i++) {
            current_prefix += nums[i];
            ans = max(ans, current_prefix - min_prefix);
            min_prefix = min(min_prefix, current_prefix);
        }
        return ans;
    }
};
```

### leetcode  118  杨辉三角

```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> c(numRows);
        for (int i = 0; i < numRows; i++) {
            c[i].resize(i + 1, 1);
            /*遍历第i行的元素*/
            for (int j = 1; j < i; j++) {
                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
            }
        }
        return c;
    }
};
```

### leetcode  279  完全平方数

```c++
class Solution {
public:
    int numSquares(int n) {
        /*创建一个大小为n+1的数组f，用于存储每个数i的最小平方数之和*/
        vector<int> f(n + 1);
        /*遍历数字*/
        for (int i = 1; i <= n; i++) {
            int minNum = INT_MAX;
            for (int j = 1; j * j <= i; j++) {
                minNum = min(minNum, f[i - j * j]);
            }
            /*f[i]的值为找到的最小值加1*/
            f[i] = minNum + 1;
        }
        return f[n];
    }
};
```

### leetcode  139  单词拆分

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        /*计算字典中最长单词的长度*/
        int max_len = ranges::max(wordDict, {}, &string::length).length();
        /*将单词字典转换为哈希集合，用于快速查找*/
        unordered_set<string> words(wordDict.begin(), wordDict.end());
        int n = s.size();
        vector<int> f(n + 1);
        f[0] = true;
        /*遍历字符串的每个位置*/
        for (int i = 1; i <= n; i++) {
            for (int j = i - 1; j >= max(i - max_len, 0); j--) {
                if (f[j] && words.count(s.substr(j, i - j))) {
                    f[i] = true;
                    break;
                }
            }
        }
        return f[n];
    }
};
```

### leetcode  152  乘积最大子数组

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        vector<int> fmax(n), fmin(n);
        fmax[0] = nums[0];
        fmin[0] = nums[0];
        /*遍历 nums 的同时，维护子数组的最大/小乘积，最后输出*/
        for (int i = 1; i < n; i++) {
            auto x = nums[i];
            fmax[i] = max({fmax[i - 1] * x, fmin[i - 1] * x, x});
            fmin[i] = min({fmax[i - 1] * x, fmin[i - 1] * x, x});
        }
        return ranges::max(fmax);
    }
};
```

###  leetcode   5   最长回文子串

```c++  
class Solution {
public:
    string longestPalindrome(string s) {
        /*在字符串的开头和结尾分别添加特殊字符 '^' 和 '$'，并在每个字符之间插入 '#'，构造一个新的字符串 t*/
        string t = "^";
        for (char c : s) {
            t += '#';
            t += c;
        }
        t += "#$";
        /*存储每个位置的回文半径*/
        vector<int> half_len(t.length() - 2);
        half_len[1] = 1;
        int box_m = 0, box_r = 0, max_i = 0;
        /*遍历新的字符串 t，从第二个位置开始*/
        for (int i = 2; i < half_len.size(); i++) {
            int hl = 1;
            if (i < box_r) {
                hl = min(half_len[box_m * 2 - i], box_r - i);
            }
            while (t[i - hl] == t[i + hl]) {
                hl++;
                box_m = i;
                box_r = i + hl;
            }

            half_len[i] = hl;
            if (hl > half_len[max_i]) {
                max_i = i;
            }
        }
        /*计算最长回文子串的起始位置和长度，并返回结果*/
        int hl = half_len[max_i];
        return s.substr((max_i - hl) / 2, hl - 1);
    }
};
```

### leetcode  32  最长有效括号

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int left = 0;
        int right = 0;
        int maxlength = 0;
        /*从左到右遍历字符串*/
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                left++;
            } else {
                right++;
            }
            /*左右括号数相等则更新有效括号长度一次*/
            if (left == right) {
                maxlength = max(maxlength, 2 * right);
            } else if (right > left) {
                left = 0;
                right = 0;
            }
        }
        left = 0;
        right = 0;
        /*从右到左遍历字符串*/
        for (int i = (int)s.length() - 1; i >= 0; i--) {
            if (s[i] == '(') {
                left++;
            } else {
                right++;
            }
            /*左右括号数相等则更新有效括号长度一次*/
            if (left == right) {
                maxlength = max(maxlength, 2 * left);
            } else if (left > right) {
                left = 0;
                right = 0;
            }
        }
        return maxlength;
    }
};
```

###  leetcode 416   分割等和子集

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int s = reduce(nums.begin(), nums.end());
        /*排除元素总和为奇数*/
        if (s % 2) {
            return false;
        }
        int n = nums.size();
        vector<vector<int>> memo(n, vector<int>(s / 2 + 1, -1));
        /*深度优先搜索*/
        auto dfs = [&](this auto&& dfs, int i, int j) -> bool {
            if (i < 0) {
                return j == 0;
            }
            /*获取当前状态的引用,如果当前状态已经计算过，直接返回结果*/
            int& res = memo[i][j];
            if (res != -1) {
                return res;
            }
            /*计算当前状态的结果*/
            return res = (j >= nums[i] && dfs(i - 1, j - nums[i])) ||
                         dfs(i - 1, j);
        };
        return dfs(n - 1, s / 2);
    }
};
```

###  leetcode  940   不同的子序列 II

```c++
class Solution {
    /*定义模数*/
    const int MOD = 1'000'000'007;

public:
    int distinctSubseqII(string s) {
        int total = 0;
        int f[26]{};
        for (auto cur : s) {
            cur -= 'a';
            int others = (total - f[cur] + MOD) % MOD;
            f[cur] = 1 + total;
            total = (f[cur] + others) % MOD;
        }
        return total;
    }
};
```

###  leetcode   718  最长重复子数组

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        int m = nums2.size();
        int ans = 0;
        vector f(n + 1, vector<int>(m + 1));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                /*两值相等则根据状态转移方程更新 f[i+1][j+1]*/
                if (nums1[i] == nums2[j]) {
                    f[i + 1][j + 1] = f[i][j] + 1;
                    ans = max(ans, f[i + 1][j + 1]);
                }
            }
        }
        return ans;
    }
};
```

### leetcode  62  不同路径

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector memo(m, vector<int>(n));
        /*重点就在于找到子问题，递归，找到状态转移方程*/
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0 || j < 0) {
                return 0;
            }
            if (i == 0 && j == 0) {
                return 1;
            }
            int& ret = memo[i][j];
            if (ret) {
                return ret;
            }
            /*状态转移方程dfs(i,j)=dfs(i−1,j)+dfs(i,j−1)*/
            return ret = dfs(i - 1, j) + dfs(i, j - 1);
        };
        return dfs(m - 1, n - 1);
    }
};
```

###  leetcode  64  最小路径和

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector memo(m, vector<int>(n, -1));
        /*记忆化搜索*/
        auto dfs = [&](this auto&& dfs, int i, int j) -> int {
            if (i < 0 || j < 0) {
                return INT_MAX;
            }
            if (i == 0 && j == 0) {
                return grid[i][j];
            }
            int& ret = memo[i][j];
            if (ret != -1) {
                return ret;
            }
            /*找到状态转移方程*/
            return ret = min(dfs(i - 1, j), dfs(i, j - 1)) + grid[i][j];
        };
        return dfs(m - 1, n - 1);
    }
};
```

### leetcode 264  丑数 II

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        /*指针初始化*/
        int idx2 = 0;
        int idx3 = 0;
        int idx5 = 0;
        vector<int> uglyNumbers(n);
        uglyNumbers[0] = 1;
        for (int i = 1; i < n; i++) {
            /*计算候选值*/
            int candidate2 = uglyNumbers[idx2] * 2;
            int candidate3 = uglyNumbers[idx3] * 3;
            int candidate5 = uglyNumbers[idx5] * 5;
            /*选择最小值*/
            uglyNumbers[i] = min({candidate2, candidate3, candidate5});
            /*独立更新指针*/
            if (uglyNumbers[i] == candidate2) {
                idx2++;
            }
            if (uglyNumbers[i] == candidate3) {
                idx3++;
            }
            if (uglyNumbers[i] == candidate5) {
                idx5++;
            }
        }
        return uglyNumbers[n - 1];
    }
};
```





