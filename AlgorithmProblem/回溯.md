# 回溯

### leetcode 17  电话号码的字母组合

```c++
class Solution {
    /*构建映射表*/
    const string MAPPING[10] = {"",    "",    "abc",  "def", "ghi",
                                "jkl", "mno", "pqrs", "tuv", "wxyz"};

public:
    vector<string> letterCombinations(string digits) {
        /*获取字符串长度*/
        int n = digits.size();
        /*处理空字符串的情况*/
        if (n == 0) {
            return {};
        }
        vector<string> ans;
        string path(n, 0);
        auto dfs = [&](this auto&& dfs, int i) -> void {
            /*处理完所有数字添加结果*/
            if (i == n) {
                ans.emplace_back(path);
                return;
            }
            /*遍历数字对应的字母*/
            for (auto& c : MAPPING[digits[i] - '0']) {
                path[i] = c;
                dfs(i + 1);
            }
        };
        /*开始深度优先搜索*/
        dfs(0);
        return ans;
    }
};
```

### leetcode 37  解数独

```c++
class Solution {
private:
    /*递归尝试填充数独棋盘的空格*/
    bool backtracking(vector<vector<char>>& board) {
        /*遍历行列*/
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                if (board[i][j] == '.') {
                    for (char k = '1'; k <= '9'; k++) {
                        if (check(i, j, k, board)) {
                            board[i][j] = k;
                            if (backtracking(board)) {
                                return true;
                            }
                            board[i][j] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
    /*校验函数*/
    bool check(int row, int col, char val, vector<vector<char>>& board) {
        /*检查当前行列是否重复*/
        for (int i = 0; i < 9; i++) {
            if (board[row][i] == val)
                return false;
        }
        for (int j = 0; j < 9; j++) {
            if (board[j][col] == val)
                return false;
        }
        /*检查3x3宫格是否重复*/
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++) {
            for (int j = startCol; j < startCol + 3; j++) {
                if (board[i][j] == val)
                    return false;
            }
        }
        return true;
    }
public:
    /*启动回溯求解*/
    void solveSudoku(vector<vector<char>>& board) { backtracking(board); }
};
```

###  leetcode  131  分割回文串

```c++
class Solution {
    /*判断子串 s[left..right] 是否为回文*/
    bool isPalindrome(string& s, int left, int right) {
        while (left < right) {
            if (s[left++] != s[right--]) {
                return false;
            }
        }
        return true;
    }

public:
    vector<vector<string>> partition(string s) {
        int n = s.length();
        vector<vector<string>> ans;
        vector<string> path;
        auto dfs = [&](this auto&& dfs, int i, int start) {
            /*已处理完所有字符*/
            if (i == n) {
                ans.emplace_back(path);
                return;
            }
            /*不在i处分割*/
            if (i < n - 1) {
                dfs(i + 1, start);
            }
            /*在i处分割*/
            if (isPalindrome(s, start, i)) {
                path.push_back(s.substr(start, i - start + 1));
                dfs(i + 1, i + 1);
                path.pop_back();
            }
        };
        dfs(0, 0);
        return ans;
    }
};
```

### leetcode  77  组合

```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> path;
        auto dfs = [&](this auto&& dfs, int i) -> void {
            int digitNum = k - path.size();
            /*已选够k个数,保存当前组合*/
            if (digitNum == 0) {
                ans.emplace_back(path);
                return;
            }
            /*剪枝优化*/
            if (i > digitNum) {
                dfs(i - 1);
            }
            /*选择当前数字*/
            path.push_back(i);
            dfs(i - 1);
            path.pop_back();
        };
        dfs(n);
        return ans;
    }
};
```
### leetcode  78  子集

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> ans;
        vector<int> path;
        auto dfs = [&](this auto&& dfs, int i) -> void {
            /*递归终止,将当前路径加入结果集*/
            if (i == n) {
                ans.emplace_back(path);
                return;
            }
            /*不选，直接递归下一层*/
            dfs(i + 1);
            /*选，选择当前数字*/
            path.push_back(nums[i]);
            dfs(i + 1);
            path.pop_back();
        };
        dfs(0);
        return ans;
    }
};
```

### leetcode 216  组合总和 III

```c++
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> ans;
        vector<int> path;
        auto dfs = [&](this auto&& dfs, int i, int t) -> void {
            int digitNum = k - path.size();
            if (t < 0 || t > (i * 2 - digitNum + 1) * digitNum / 2) {
                return;
            }
            /*保存结果*/
            if (digitNum == 0) {
                ans.emplace_back(path);
                return;
            }
            /*不选 i*/
            if (i > digitNum) {
                dfs(i - 1, t);
            }
            /*选 i*/
            path.push_back(i);
            dfs(i - 1, t - i);
            path.pop_back();
        };
        dfs(9, n);
        return ans;
    }
};
```

### leetcode 22   括号生成

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        int m = n * 2;
        vector<string> ans;
        string path(m, 0);
        auto dfs = [&](this auto&& dfs, int i, int leftNum) {
            /*所有位置填充完毕*/
            if (i == m) {
                ans.emplace_back(path);
                return;
            }
            /*尝试放置左括号*/
            if (leftNum < n) {
                path[i] = '(';
                dfs(i + 1, leftNum + 1);
            }
            /*尝试放置右括号*/
            if (i - leftNum < leftNum) {
                path[i] = ')';
                dfs(i + 1, leftNum);
            }
        };
        dfs(0, 0);
        return ans;
    }
};
```


### leetcode  46   全排列

```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> ans;
        vector<int> path(n);
        vector<int> on_path(n);
        auto dfs = [&](this auto&& dfs, int i) {
            /*已生成完整排列则保存*/
            if (i == n) {
                ans.emplace_back(path);
                return;
            }
            /*遍历所有数字*/
            for (int j = 0; j < n; j++) {
                /*若元素未使用*/
                if (!on_path[j]) {
                    /*选择数字*/
                    path[i] = nums[j];
                    on_path[j] = true;
                    /*填充下一个位置*/
                    dfs(i + 1);
                    /*回溯*/
                    on_path[j] = false;
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```

### leetcode  39  组合总和

```c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> path;
        function<void(int, int)> dfs = [&](int i, int left) {
            if (left == 0) {
                /*找到一个合法组合*/
                ans.push_back(path);
                return;
            }
            if (i == candidates.size() || left < 0) {
                return;
            }
            /*不选*/
            dfs(i + 1, left);
            /*选*/
            path.push_back(candidates[i]);
            dfs(i, left - candidates[i]);
            path.pop_back();
        };
        dfs(0, target);
        return ans;
    }
};
```

### leetcode   79    单词搜索

```c++  
class Solution {
    static constexpr int DIRS[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

public:
    bool exist(vector<vector<char>>& board, string word) {
        unordered_map<char, int> cnt;
        for (auto& row : board) {
            for (char c : row) {
                cnt[c]++;
            }
        }
        /*检查单词字符是否全部在board中存在*/
        unordered_map<char, int> word_cnt;
        for (char c : word) {
            if (++word_cnt[c] > cnt[c]) {
                return false;
            }
        }
        /*反转单词优化搜索效率*/
        if (cnt[word.back()] < cnt[word[0]]) {
            ranges::reverse(word);
        }
        int m = board.size(), n = board[0].size();
        auto dfs = [&](this auto&& dfs, int i, int j, int k) -> bool {
            /*当前字符不匹配，返回失败,匹配则成功*/
            if (board[i][j] != word[k]) {
                return false;
            }
            if (k + 1 == word.length()) {
                return true;
            }
            char temp = board[i][j];
            board[i][j] = 0;
            /*递归搜索*/
            for (auto& [dx, dy] : DIRS) {
                int x = i + dx, y = j + dy;
                if (0 <= x && x < m && 0 <= y && y < n) {
                    if (dfs(x, y, k + 1)) {
                        return true;
                    }
                }
            }
            /*恢复原始字符*/
            board[i][j] = temp;
            return false;
        };
        /*遍历所有单元格作为起点*/
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }
};
```

###  leetcode 51  N皇后

```c++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;
        vector board(n, string(n, '.'));
        vector<uint8_t> col(n, false);
        vector<uint8_t> diag1(n * 2 - 1, false);
        vector<uint8_t> diag2(n * 2 - 1, false);
        auto dfs = [&](this auto&& dfs, int r) {
            /*所有行都已放置皇后*/
            if (r == n) {
                ans.push_back(board);
                return;
            }
            /*放置皇后*/
            for (int c = 0; c < n; c++) {
                /*计算两条对角线的索引*/
                int diag1_idx = r + c;
                int diag2_idx = r - c + n - 1;
                /*检查当前位置是否安全*/
                if (!col[c] && !diag1[diag1_idx] && !diag2[diag2_idx]) {
                    /*放置皇后,标记并回溯*/
                    board[r][c] = 'Q';
                    col[c] = diag1[diag1_idx] = diag2[diag2_idx] = true;
                    dfs(r + 1);
                    col[c] = diag1[diag1_idx] = diag2[diag2_idx] = false;
                    board[r][c] = '.';
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```

### leetcode X

```c++
```

