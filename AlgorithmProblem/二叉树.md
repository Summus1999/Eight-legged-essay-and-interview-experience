# 二叉树

### leetcode 94 二叉树的中序遍历

```c++
class Solution {
    void traversal(TreeNode* cur, vector<int>& vec) {
        /*递归终止条件：当前节点为空*/
        if (!cur) {
            return;
        }
        /*递归遍历左子树,访问当前节点，递归遍历右子树*/
        traversal(cur->left, vec);
        vec.push_back(cur->val);
        traversal(cur->right, vec);
    }

public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        /*从根节点开始递归遍历*/
        traversal(root, ans);
        return ans;
    }
};

```

### leetcode  98  验证二叉搜索树

```c++
class Solution {
    long long pre = LLONG_MIN;

public:
    bool isValidBST(TreeNode* root) {
        /*处理头节点为空的情况，直接返回 TRUE*/
        if (root == nullptr) {
            return true;
        }
        /*递归检查左子树*/
        if (!isValidBST(root->left)) {
            return false;
        }
        /*检查当前节点的值是否大于前一个节点的值*/
        if (root->val <= pre) {
            return false;
        }
        /*更新前一个节点的值为当前节点的值*/
        pre = root->val;
        /*递归检查右子树*/
        return isValidBST(root->right);
    }
};
```

### leetcode 100 相同的树

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        /*当前节点如果为空，左右子树必须都是nullptr*/
        if (q == nullptr || p == nullptr) {
            return q == p;
        }
        /*遍历左右子树*/
        return q->val == p->val && isSameTree(p->left, q->left) &&
               isSameTree(p->right, q->right);
    }
};
```

### leetcode  101  对称二叉树

```c++
class Solution {
    bool isSameTree(TreeNode* p, TreeNode* q) {
        /*处理有空指针的情况*/
        if (!p || !q) {
            return p == q;
        }
        /*二叉树对称需要值相等且左右子树镜像对称*/
        return p->val == q->val && isSameTree(p->right, q->left) &&
               isSameTree(p->left, q->right);
    }

public:
    bool isSymmetric(TreeNode* root) {
        return isSameTree(root->left, root->right);
    }
};
```

### leetcode  102  二叉树的层序遍历

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        /*若根节点为空，直接返回空二维数组*/
        if (!root) {
            return {};
        }
        vector<vector<int>> ans;
        queue<TreeNode*> q;
        q.push(root);
        /*循环处理直到队列为空*/
        while (!q.empty()) {
            vector<int> vals;
            /*保存当前层节点数*/
            for (int n = q.size(); n > 0; n--) {
                auto node = q.front();
                q.pop();
                vals.push_back(node->val);
                /*将非空子节点加入队列*/
                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
            /*存入结果*/
            ans.emplace_back(vals);
        }
        return ans;
    }
};
```

### leetcode 103  二叉树的锯齿形层序遍历

```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        if (!root) {
            return {};
        }
        vector<vector<int>> ans;
        vector<TreeNode*> cur = {root};
        bool leftToRight = true;
        while (!cur.empty()) {
            vector<TreeNode*> nxt;
            vector<int> vals;
            vals.reserve(cur.size());
            /*遍历当前层节点*/
            for (auto node : cur) {
                /*从左往右就尾插，否则头插*/
                if (leftToRight) {
                    vals.push_back(node->val);
                } else {
                    vals.insert(vals.begin(), node->val);
                }
                /*子节点入队*/
                if (node->left) {
                    nxt.push_back(node->left);
                }
                if (node->right) {
                    nxt.push_back(node->right);
                }
            }
            cur = move(nxt);            
            ans.push_back(move(vals));  
            leftToRight = !leftToRight; 
        }
        return ans;
    }
};
```

### leetcode 104 二叉树的最大深度

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        /*递归寻找左右子树的深度，找一个最大值然后+1即可*/
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        return max(leftDepth, rightDepth) + 1;
    }
};
```

### leetcode 105  从前序与中序遍历序列构造二叉树

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (preorder.empty()) {
            return nullptr;
        }
        /*确定根节点*/
        int left_size = ranges::find(inorder, preorder[0]) - inorder.begin();
        /*构建左子树的前序遍历 中序遍历*/
        vector<int> pre1(preorder.begin() + 1,
                         preorder.begin() + 1 + left_size);
        vector<int> in1(inorder.begin(), inorder.begin() + left_size);
        /*构建右子树的前序遍历 中序遍历*/
        vector<int> pre2(preorder.begin() + 1 + left_size, preorder.end());
        vector<int> in2(inorder.begin() + 1 + left_size, inorder.end());
        TreeNode* left = buildTree(pre1, in1);
        TreeNode* right = buildTree(pre2, in2);
        return new TreeNode(preorder[0], left, right);
    }
};
```

### leetcode  106  从中序与后序遍历序列构造二叉树

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (postorder.empty()) {
            return nullptr;
        }
        /*根节点是后序最后一个元素*/
        int root_val = postorder.back();
        TreeNode* root = new TreeNode(root_val);
        /*单节点直接返回*/
        if (postorder.size() == 1) {
            return root;
        }
        /*在中序中找到根节点位置*/
        auto root_it = ranges::find(inorder, root_val);
        int left_size = root_it - inorder.begin();
        int right_size = inorder.end() - root_it - 1;
        /*切割左子树的中序和后序*/
        vector<int> left_in(inorder.begin(), root_it);
        vector<int> left_post(postorder.begin(), postorder.begin() + left_size);
        /*切割右子树的中序和后序,排除根节点*/
        vector<int> right_in(root_it + 1, inorder.end());
        vector<int> right_post(postorder.begin() + left_size,
                               postorder.end() - 1);
        /*递归构建*/
        root->left = buildTree(left_in, left_post);
        root->right = buildTree(right_in, right_post);
        return root;
    }
};
```

### leetcode  107  二叉树的层序遍历 II

```c++
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        /*处理空树情况*/
        if (!root) {
            return {};
        }
        vector<vector<int>> ans;
        vector<TreeNode*> cur{root};
        /*逐层遍历，直到当前层无节点*/
        while (cur.size()) {
            vector<TreeNode*> nxt;
            vector<int> vals;
            /*遍历当前层所有节点*/
            for (auto node : cur) {
                vals.push_back(node->val);
                if (node->left) {
                    nxt.push_back(node->left);
                }
                if (node->right) {
                    nxt.push_back(node->right);
                }
            }
            /*更新当前层为下一层并存储结果*/
            cur = move(nxt);
            ans.emplace_back(vals);
        }
        /*反转结果*/
        ranges::reverse(ans);
        return ans;
    }
};
```

### leetcode 108  将有序数组转换为二叉搜索树

```c++
class Solution {
    TreeNode* dfs(vector<int>& nums, int left, int right) {
        /*左右两个数相等则构建不了BST*/
        if (left == right) {
            return nullptr;
        }
        /*创建当前节点，递归创建左右子树*/
        int mid = left + (right - left) / 2;
        return new TreeNode(nums[mid], dfs(nums, left, mid),
                            dfs(nums, mid + 1, right));
    }

public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return dfs(nums, 0, nums.size());
    }
};
```

### leetcode 110  平衡二叉树

```c++
class Solution {
    int get_height(TreeNode* node) {
        /*空节点的高度为0*/
        if (node == nullptr) {
            return 0;
        }
        int left_h = get_height(node->left);
        if (left_h == -1) {
            return -1;
        }
        int right_h = get_height(node->right);
        if (right_h == -1 || abs(left_h - right_h) > 1) {
            return -1;
        }

        return max(left_h, right_h) + 1;
    }

public:
    bool isBalanced(TreeNode* root) {
        /*如果树的高度不为-1，则树是平衡的*/
        return get_height(root) != -1;
    }
};
```

### leetcode 111 二叉树的最小深度

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        /*初始化最小深度为最大值*/
        int ans = INT_MAX;
        /*自顶向下递归*/
        auto dfs = [&](this auto&& dfs, TreeNode* node, int cnt) -> void {
            if (!node) {
                return;
            }
            cnt++;
            /*对子节点更新最小深度并终止本路径*/
            if (!node->left && !node->right) {
                ans = min(ans, cnt);
                cnt++;
            }
            /*归遍历左子树和右子树*/
            dfs(node->left, cnt);
            dfs(node->right, cnt);
        };
        dfs(root, 0);
        return root ? ans : 0;
    }
};	
```

### leetcode 112  路径总和

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (!root) {
            return false;
        }
        /*更新目标和*/
        targetSum -= root->val;
        /*检查当前节点是否为叶子节点*/
        if (!root->left && !root->right) {
            return targetSum == 0;
        }
        /*递归检查左右子树*/
        return hasPathSum(root->left, targetSum) ||
               hasPathSum(root->right, targetSum);
    }
};
```

### leetcode  114  二叉树展开为链表

```c++
class Solution {
    TreeNode* head;

public:
    void flatten(TreeNode* root) {
        /*处理入参空指针情况*/
        if (root == nullptr) {
            return;
        }
        /*遍历右子树，左子树*/
        flatten(root->right);
        flatten(root->left);
        /*使用头插法*/
        root->left = nullptr;
        root->right = head;
        head = root;
    }
};
```

### leetcode 124  二叉树中的最大路径和

```c++
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        int ans = INT_MIN;
        auto dfs = [&](this auto&& dfs, TreeNode* node) -> int {
            if (!node) {
                return 0;
            }
            /*递归计算左右子树的最大单边路径和*/
            int l_val = dfs(node->left);
            int r_val = dfs(node->right);
            /*更新全局最大路径和*/
            ans = max(ans, l_val + r_val + node->val);
            return max(max(l_val, r_val) + node->val, 0);
        };
        dfs(root);
        return ans;
    }
};
```

### leetcode 129  求根节点到叶节点数字之和

```c++
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        int ans = 0;
        auto dfs = [&](this auto&& dfs, TreeNode* node, int x) -> void {
            /*节点为空直接返回*/
            if (!node) {
                return;
            }
            x = x * 10 + node->val;
            /*当当前节点为叶子节点时加入结果*/
            if (!node->left && !node->right) {
                ans += x;
            }
            dfs(node->left, x);
            dfs(node->right, x);
        };
        dfs(root, 0);
        return ans;
    }
};
```

### leetcode  199  二叉树的右视图

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        /*首次遇到该深度则记录值*/
        vector<int> ans;
        auto dfs = [&](this auto&& dfs, TreeNode* node, int depth) -> void {
            if (node == nullptr) {
                return;
            }
            if (depth == ans.size()) {
                ans.push_back(node->val);
            }
            /*右视图先遍历右子树*/
            dfs(node->right, depth + 1);
            dfs(node->left, depth + 1);
        };
        dfs(root, 0);
        return ans;
    }
};
```

### leetcode  226 翻转二叉树

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        /*处理入参空指针的情况*/
        if (!root) {
            return nullptr;
        }
        /*先翻转下面的节点，最后反转根节点即可*/
        auto left = invertTree(root->left);
        auto right = invertTree(root->right);
        root->right = left;
        root->left = right;
        return root;
    }
};
```

### leetcode  230  二叉搜索树中第K小的元素

```c++
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        /*递归左子树，然后当k减少1之后为0则记录该节点的值即可*/
        int ans=0;
        auto dfs=[&](this auto && dfs,TreeNode *node){
            if(node==nullptr||k==0){
                return;
            }
            /*递归左子树，k递归到0记录答案即可*/
            dfs(node->left);
            k--;
            if(k==0){
                ans=node->val;
            }
            dfs(node->right);
        };
        dfs(root);
        return ans;
    }
};
```

### leetcode 235  二叉搜索树的最近公共祖先

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        int cur = root->val;
        /*如果都小于当前节点值递归搜索左子树，反之搜索右子树*/
        if (p->val < cur && q->val < cur) {
            return lowestCommonAncestor(root->left, p, q);
        }
        if (p->val > cur && q->val > cur) {
            return lowestCommonAncestor(root->right, p, q);
        }
        /*p,q在一个在左子树一个在右子树，最近公共祖先就是当前节点*/
        return root;
    }
};
```

### leetcode 236  二叉树的最近公共祖先

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        /*若当前节点为空或等于p/q，直接返回当前节点*/
        if (!root || root == p || root == q) {
            return root;
        }
        /*递归搜索左右子树*/
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        /*左右子树均找到目标节点,返回当前节点*/
        if (left && right) {
            return root;
        }
        /*看左子树是否为空，为空则递归右子树*/
        return left ? left : right;
    }
};
```

###  leetcode  437  路径总和 III

```c++
class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {
        int ans = 0;
        /*哈希表记录路径前缀和出现的次数*/
        unordered_map<long long, int> cnt{{0, 1}};
        auto dfs = [&](this auto&& dfs, TreeNode* node, long long s) {
            if (!node) {
                return;
            }
            /*更新当前路径和*/
            s += node->val;
            /*查找是否存在路径和差值满足条件*/
            ans += cnt[s - targetSum];
            cnt[s]++;
            /*递归遍历左右子树*/
            dfs(node->left, s);
            dfs(node->right, s);
            cnt[s]--;
        };
        dfs(root, 0);
        return ans;
    }
};
```

### leetcode  543 二叉树的直径

```c++
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        int ans = 0;
        auto dfs = [&](this auto&& dfs, TreeNode* node) -> int {
            /*处理入参空指针的情况*/
            if (node == nullptr) {
                return -1;
            }
            /*计算从当前节点到其最深叶子节点的路径长度，找出最长子树*/
            int left_len = dfs(node->left) + 1;
            int right_len = dfs(node->right) + 1;
            ans = max(ans, left_len + right_len);
            return max(left_len, right_len);
        };
        dfs(root);
        return ans;
    }
};
```

### leetcode 572 另一棵树的子树

```c++
class Solution {
    /*求二叉树的最大深度*/
    int getHeight(TreeNode* node) {
        if (!node) {
            return 0;
        }
        int left_h = getHeight(node->left);
        int right_h = getHeight(node->right);
        return max(left_h, right_h) + 1;
    }
    /*判断是否为相同的树*/
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == nullptr || q == nullptr) {
            return p == q; // 必须都是 nullptr
        }
        return p->val == q->val && isSameTree(p->left, q->left) &&
               isSameTree(p->right, q->right);
    }

public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        int treeHeight = getHeight(subRoot);
        auto dfs = [&](this auto&& dfs, TreeNode* node) -> pair<int, bool> {
            if (!node) {
                return {0, false};
            }
            /*递归左右子树直到找到子树*/
            auto [left_h, left_found] = dfs(node->left);
            auto [right_h, right_found] = dfs(node->right);
            if (left_found || right_found) {
                return {0, true};
            }
            int node_h = max(left_h, right_h) + 1;
            bool found = (node_h == treeHeight && isSame(node, subRoot));
            return {node_h, found};
        };
        return dfs(root).second;
    }
};
```

### leetcode 700 二叉搜索树中的搜索

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        /*开始一个循环，直到当前节点为空*/
        while (root) {
            if (root->val == val) {
                return root;
            }
            root = val < root->val ? root->left : root->right;
        }
        /*搜不到对应的节点值返回nullptr*/
        return nullptr;
    }
};
```

### leetcode 938  二叉搜索树的范围和

```c++
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        /*如果当前节点为空，返回 0*/
        if (root == nullptr) {
            return 0;
        }
        int x = root->val;
        /*递归左子树*/
        if (x > high) {
            return rangeSumBST(root->left, low, high);
        }
        /*递归右子树*/
        if (x < low) {
            return rangeSumBST(root->right, low, high);
        }
        /*累加范围和*/
        return x + rangeSumBST(root->left, low, high) +
               rangeSumBST(root->right, low, high);
    }
};
```

### leetcode 987  二叉树的垂序遍历

```c++
class Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        map<int, vector<pair<int, int>>> groups;
        auto dfs = [&](this auto&& dfs, TreeNode* node, int row,
                       int col) -> void {
            if (!node) {
                return;
            }

            /*记录当前节点*/
            groups[col].emplace_back(row, node->val);

            /*递归遍历左右子树*/
            dfs(node->left, row + 1, col - 1);
            dfs(node->right, row + 1, col + 1);
        };
        dfs(root, 0, 0);
        vector<vector<int>> ans;
        for (auto& [col, nodes] : groups) {
            /*节点排序*/
            sort(nodes.begin(), nodes.end());
            /*提取节点值*/
            vector<int> vals;
            for (auto& [row, val] : nodes) {
                vals.push_back(val);
            }
            ans.push_back(vals);
        }
        return ans;
    }
};
```

### leetcode 1382  将二叉搜索树变平衡

```c++
class Solution {
private:
    vector<int> vec;
    /*中序遍历*/
    void traversal(TreeNode* node) {
        if (!node) {
            return;
        }
        traversal(node->left);
        vec.push_back(node->val);
        traversal(node->right);
    }
    // 有序数组转平衡二叉树
    TreeNode* getTree(vector<int>& nums, int left, int right) {
        if (left > right) {
            return nullptr;
        }
        /*选择中间节点为根,递归构建左右子树*/
        int mid = left + ((right - left) / 2);
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = getTree(nums, left, mid - 1);
        root->right = getTree(nums, mid + 1, right);
        return root;
    }

public:
    TreeNode* balanceBST(TreeNode* root) {
        /*BST转有序数组vec，再转平衡BST*/
        traversal(root);
        return getTree(vec, 0, vec.size() - 1);
    }
};
```

### leetcode  1448  统计二叉树中好节点的数目

```c++
class Solution {
public:
    int goodNodes(TreeNode* root) {
        auto dfs = [](auto&& self, TreeNode* node, int max_val) -> int {
            if (!node){
                return 0;
            }
            int count = 0;
            /*更新最大值*/
            if (node->val >= max_val) {
                count = 1;
                max_val = node->val;
            }
            /*传递更新后的最大值*/
            count += self(self, node->left, max_val);
            count += self(self, node->right, max_val);
            return count;
        };
        return dfs(dfs, root, INT_MIN);
    }
};
```









