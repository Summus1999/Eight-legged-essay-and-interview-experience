# 数组

### leetcode 88 合并两个有序数组

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        /*元素复制到尾部*/
        for (int i = 0; i < n; i++) {
            nums1[m + i] = nums2[i];
        }
        /*排序*/
        ranges::sort(nums1);
    }
};
```

### leetcode 189 轮转数组

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        /*计算有效旋转步数*/
        k %= nums.size();
        /*三步反转实现轮转*/
        ranges::reverse(nums);
        reverse(nums.begin(), nums.begin() + k);
        reverse(nums.begin() + k, nums.end());
    }
};
```

### leetcode  75  颜色分类

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n=nums.size();
        int red=0;
        int white=0;
        int blue=0;
        for(auto num:nums){
            if(num==0){
                red++;
            }else if(num==1){
                white++;
            }else{
                blue++;
            }
        }
        for(int i=0;i<n;i++){
            if(i>=0&&i<red){
                nums[i]=0;
            }else if(i>=red+white){
                nums[i]=2;
            }else{
                nums[i]=1;
            }
        }
    }
};
```

### leetcode 31  下一个排列

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        ranges::next_permutation(nums);
    }
};
```

###  leetcode  1535  找出数组游戏的赢家

```c++
class Solution {
public:
    int getWinner(vector<int>& arr, int k) {
        int maxNum = arr[0];
        int win = 0;
        /*遍历数组,如果出现当前最大值失败的情况就重置胜利次数*/
        for (int i = 1; i < arr.size() && win < k; i++) {
            if (arr[i] > maxNum) {
                maxNum = arr[i];
                win = 0;
            }
            win++;
        }
        return maxNum;
    }
};
```

### leetcode 624  数组列表中的最大距离

```c++
class Solution {
public:
    int maxDistance(vector<vector<int>>& arrays) {
        int ans = 0;
        int miniNum = INT_MAX / 2;
        int maxNum = INT_MIN / 2;
        /*遍历每个数组*/
        for (auto& current : arrays) {
            /*更新答案*/
            ans = max({ans, current.back() - miniNum, maxNum - current[0]});
            miniNum = min(miniNum, current[0]);
            maxNum = max(maxNum, current.back());
        }
        return ans;
    }
};
```

### leetcode   357  统计各位数字都不同的数字个数

```c++
class Solution {
public:
    int countNumbersWithUniqueDigits(int n) {
        if (n == 0) {
            return 1;
        }
        if (n == 1) {
            return 10;
        }
        /*初始化结果为 10*/
        int result = 10;
        /*当前位数的组合数*/
        int currentCombination = 9;
        for (int i = 0; i < n - 1; i++) {
            currentCombination *= (9 - i);
            result += currentCombination;
        }
        return result;
    }
};
```

### leetcode  26  删除有序数组中的重复项

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        /*双指针法，如果vector长度为0则返回*/
        int n = nums.size();
        if (!n) {
            return 0;
        }
        int slow = 1;
        int fast = 1;
        /*如果fast指针遇到前后数字不相等则数字不重复，赋值给slow指针即可*/
        while (fast < n) {
            if (nums[fast] != nums[fast - 1]) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

### leetcode 674  最长连续递增序列

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int ans = 0;        
        int n = nums.size(); 
        int start = 0;       
        for (int i = 0; i < n; i++) {
            /*重置*/
            if (i > 0 && nums[i] <= nums[i - 1]) {
                start = i;
            }
            /*更新全局最大值*/
            ans = max(ans, i - start + 1);
        }
        return ans;
    }
};
```

### leetcode 380  O(1) 时间插入、删除和获取随机元素

```c++
class RandomizedSet {
private:
    std::vector<int> nums;
    std::unordered_map<int, int> indices;

public:
    /*初始化随机数种子*/
    RandomizedSet() { srand((unsigned)time(NULL)); }
    /*插入元素*/
    bool insert(int val) {
        if (indices.count(val)) {
            return false;
        }
        int index = nums.size();
        nums.emplace_back(val);
        indices[val] = index;
        return true;
    }
    /*移除元素*/
    bool remove(int val) {
        if (!indices.count(val)) {
            return false;
        }
        int index = indices[val];
        int last = nums.back();
        /*用最后一个元素覆盖待删除元素*/
        nums[index] = last;
        indices[last] = index;
        nums.pop_back();
        indices.erase(val);
        return true;
    }
    /*生成随机索引*/
    int getRandom() {
        int randomIndex = rand() % nums.size();
        return nums[randomIndex];
    }
};
```

### leetcode 135  分发糖果

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        if (n <= 1) {
            return n;
        }
        vector<int> candies(n, 1);
        /*正向遍历*/
        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i - 1]) {
                candies[i] = candies[i - 1] + 1;
            }
        }
        /*反向遍历*/
        int ans = candies[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) {
                candies[i] = max(candies[i], candies[i + 1] + 1);
            }
            ans += candies[i];
        }
        return ans;
    }
};
```

### leetcode 228 汇总区间

```c++
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> ans;
        int i = 0;
        int n = nums.size();
        /*遍历整个数组*/
        while (i < n) {
            int low = i;
            i++;
            /*探测连续区间的终点*/
            while (i < n && nums[i] == nums[i - 1] + 1) {
                i++;
            }
            int high = i - 1;
            /*生成区间字符串*/
            string temp = to_string(nums[low]);
            if (low < high) {
                temp.append("->");
                temp.append(to_string(nums[high]));
            }
            ans.push_back(move(temp));
        }
        return ans;
    }
};
```

### leetcode  334  递增的三元子序列

```c++
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int first = INT_MAX;
        int second = INT_MAX;
        for (auto num : nums) {
            if (num <= first) {
                /*更新最小值*/
                first = num;
            } else if (num <= second) {
                /*更新次小值*/
                second = num;
            } else {
                /*找到大于second的值*/
                return true;
            }
        }
        return false;
    }
};
```

### leetcode 3487   删除后的最大子数组元素和

```c++
class Solution {
public:
    int maxSum(vector<int>& nums) {
        unordered_set<int> uniquePositives;
        int sum = 0;
        int maxNegative = INT_MIN;
        for (auto num : nums) {
            if (num < 0) {
                /*更新最大负数*/
                maxNegative = max(maxNegative, num);
            } else if (uniquePositives.insert(num).second) {
                sum += num;
            }
        }
        /*根据是否存在非负数返回结果*/ 
        return uniquePositives.empty() ? maxNegative : sum;
    }
};
```



 



