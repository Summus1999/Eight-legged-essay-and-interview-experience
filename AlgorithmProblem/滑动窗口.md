#  滑动窗口

### leetcode 3  无重复字符的最长子串

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int left = 0;
        int ans = 0;
        unordered_map<int, int> hash;
        /*使用哈希表，如果有某个元素的频率超过1就缩小窗口*/
        for (int right = 0; right < n; right++) {
            auto cur = s[right];
            hash[cur]++;
            while (hash[cur] > 1) {
                hash[s[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

### leetcode 16 最接近的三数之和

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        ranges::sort(nums);
        int n = nums.size();
        int ans = nums[0] + nums[1] + nums[2];
        for (int i = 0; i <= n - 3; i++) {
            auto cur = nums[i];
            if (i > 0 && cur == nums[i - 1]) {
                continue;
            }
            /*剪枝1*/
            if (cur + nums[i + 1] + nums[i + 2] > target) {
                if (abs(cur + nums[i + 1] + nums[i + 2] - target) <
                    abs(ans - target)) {
                    ans = cur + nums[i + 1] + nums[i + 2];
                }
                continue;
            }
            /*剪枝2*/
            if (cur + nums[n - 1] + nums[n - 2] < target) {
                if (abs(cur + nums[n - 1] + nums[n - 2] - target) <
                    abs(ans - target)) {
                    ans = cur + nums[n - 1] + nums[n - 2];
                }
                continue;
            }
            int j = i + 1;
            int k = n - 1;
            while (j < k) {
                auto sum = cur + nums[j] + nums[k];
                if (sum == target) {
                    return sum;
                }
                /*更新最佳和*/
                if (abs(sum - target) < abs(ans - target)) {
                    ans = sum;
                }
                /*根据和与目标值的关系移动指针*/
                if (sum < target) {
                    for (j++; j < k && nums[j] == nums[j - 1]; j++) {
                        continue;
                    }
                } else {
                    for (k--; j < k && nums[k] == nums[k + 1]; k--) {
                        continue;
                    }
                }
            }
        }
        return ans;
    }
};
```

### leetcode  18  四数之和

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int a = 0; a <= n - 4; a++) {
            long long x = nums[a];
            if (a > 0 && x == nums[a - 1]) {
                continue;
            }
            if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) {
                break;
            }
            if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) {
                continue;
            }
            for (int b = a + 1; b <= n - 3; b++) { // 枚举第二个数
                auto y = nums[b];
                if (b > a + 1 && y == nums[b - 1]) {
                    continue;
                }

                if (x + y + nums[b + 1] + nums[b + 2] > target) {
                    break;
                }
                if (x + y + nums[n - 2] + nums[n - 1] < target) {
                    continue;
                }
                int c = b + 1;
                int d = n - 1;
                /*双指针枚举第三个数和第四个数*/
                while (c < d) {
                    long long sum = x + y + nums[c] + nums[d];
                    if (sum > target) {
                        d--;
                    }
                    else if (sum < target) {
                        c++;
                    } else {
                        /*sum==target*/
                        ans.push_back({(int)x, (int)y, nums[c], nums[d]});
                        for (c++; c < d && nums[c] == nums[c - 1]; c++) {
                            continue;
                        }
                        for (d--; d > c && nums[d] == nums[d + 1]; d--) {
                            continue;
                        }
                    }
                }
            }
        }
        return ans;
    }
};
```

### leetcode   76  最小覆盖子串

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        /*初始化最小窗口边界*/
        int ans_left = -1;
        int ans_right = s.length();
        int hash[128]{};
        int debt = 0;
        /*遍历字符串并初始化哈希表*/
        for (auto cur : t) {
            if (hash[cur] == 0) {
                debt++;
            }
            hash[cur]++;
        }
        /*初始化滑动窗口左指针*/
        int left = 0;
        for (int right = 0; right < s.length(); right++) {
            char c = s[right];
            hash[c]--;
            if (hash[c] == 0) {
                debt--;
            }
            /*满足覆盖条件下缩小窗口*/
            while (debt == 0) {
                if (right - left < ans_right - ans_left) {
                    ans_left = left;
                    ans_right = right;
                }
                char current = s[left];
                if (hash[current] == 0) {
                    debt++;
                }
                hash[current]++;
                left++;
            }
        }
        return (ans_left < 0) ? ""
                              : s.substr(ans_left, ans_right - ans_left + 1);
    }
};
```

### leetcode 125  验证回文串

```c++
class Solution {
public:
    bool isPalindrome(string s) {
        int n = s.size();
        int left = 0;
        int right = n - 1;
        /*双指针遍历字符串,都是有效字符再对比*/
        while (left <= right) {
            if (!isalnum(s[left])) {
                left++;
            } else if (!isalnum(s[right])) {
                right--;
            } else if (tolower(s[left]) == tolower(s[right])) {
                left++;
                right--;
            } else {
                return false;
            }
        }
        return true;
    }
};
```

### leetcode  209  长度最小的子数组

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int ans = n + 1;
        int left = 0;
        int currentNum = 0;
        for (int right = 0; right < n; right++) {
            currentNum += nums[right];
            /*如果当前窗口和大于target直接缩窗即可，更新ans*/
            while (currentNum >= target) {
                ans = min(ans, right - left + 1);
                currentNum -= nums[left];
                left++;
            }
        }
        return (ans <= n) ? ans : 0;
    }
};
```

###  leetcode  239   滑动窗口最大值

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> ans; 
        deque<int> q;    
        for (int i = 0; i < nums.size(); i++) {
            /*维护队列单调性：从队尾移除比当前元素小的索引*/
            while (!q.empty() && nums[q.back()] <= nums[i]) {
                q.pop_back();
            }
            q.push_back(i);
            /*移除超出窗口范围的队首元素*/
            if (!q.empty() && q.front() <= i - k) {
                q.pop_front();
            }
            /*记录当前窗口最大值*/
            if (i >= k - 1) {
                ans.push_back(nums[q.front()]);
            }
        }
        return ans;
    }
};
```

### leetcode  344  反转字符串

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int n = s.size();
        /*双指针交换，往中间靠拢*/
        for (int left = 0, right = n - 1; left < right; left++, right--) {
            swap(s[left], s[right]);
        }
    }
}
```

### leetcode  611  有效三角形的个数

```c++
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        ranges::sort(nums);
        int ans = 0;
        int n = nums.size();
        /*固定最大边*/
        for (int i = n - 1; i >= 2; i--) {
            int left = 0;
            int right = i - 1;
            /*双指针向中间收缩*/
            while (left < right) {
                if (nums[left] + nums[right] > nums[i]) {
                    ans += right - left;
                    right--;
                } else {
                    left++;
                }
            }
        }
        return ans;
    }
};
```

### leetcode  643  子数组最大平均数 I

```c++
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        double ans = 0;
        double cur = 0;
        double n = nums.size();
        /*先获取初始值*/
        for (int i = 0; i < k; i++) {
            ans += nums[i];
        }
        /*过渡初始值并不断更新最大值*/
        cur = ans;
        for (int i = 1; i + k <= n; i++) {
            cur += (nums[i + k - 1] - nums[i - 1]);
            ans = max(cur, ans);
        }
        return ans / k;
    }
};
```

### leetcode 713  乘积小于K的子数组

```c++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        /*异常情况处理*/
        if (k <= 1) {
            return 0;
        }
        int n = nums.size();
        int left = 0;
        int ans = 0;
        int cur = 1;
        /*遍历数组，right是滑动窗口的右边界*/
        for (int right = 0; right < n; right++) {
            cur *= nums[right];
            while (cur >= k) {
                cur /= nums[left];
                left++;
            }
            ans += right - left + 1;
        }
        return ans;
    }
};
```

### leetcode 904  水果成篮

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        /*灵神不定长滑动窗口模板题*/
        unordered_map<int, int> hash;
        int ans = 0;
        int left = 0;
        int n = fruits.size();
        for (int right = 0; right < n; right++) {
            hash[fruits[right]]++;
            /*如果超过2种水果就移动左指针*/
            while (hash.size() > 2) {
                int out = fruits[left];
                hash[out]--;
                if (hash[out] == 0) {
                    hash.erase(out);
                }
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

### leetcode 930  和相同的二元子数组

```c++
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
        int n = nums.size();
        int left1 = 0;
        int left2 = 0;
        int sum1 = 0;
        int sum2 = 0;
        int ans = 0;
        for (int right = 0; right < n; right++) {
            /*维护两个窗口并更新答案*/
            sum1 += nums[right];
            while (left1 <= right && sum1 > goal) {
                sum1 -= nums[left1];
                left1++;
            }
            sum2 += nums[right];
            while (left2 <= right && sum2 >= goal) {
                sum2 -= nums[left2];
                left2++;
            }
            ans += left2 - left1;
        }
        return ans;
    }
};
```

### leetcode 977  有序数组的平方

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        int left = 0;
        int right = n - 1;
        for (int pos = n - 1; pos >= 0; pos--) {
            /*计算当前左右指针元素的平方值*/
            int x = nums[left] * nums[left];
            int y = nums[right] * nums[right];
            /*选择较大的平方值填充，并移动指针*/
            if (x > y) {
                ans[pos] = x;
                left++;
            } else {
                ans[pos] = y;
                right--;
            }
        }
        return ans;
    }
};
```

### leetcode   1004  最大连续1的个数 III

```c++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int ans = 0;
        int left = 0;
        int n = nums.size();
        unordered_map<int, int> hash;
        for (int right = 0; right < n; right++) {
            hash[nums[right]]++;
            while (hash.find(0) != hash.end() && hash[0] > k) {
                hash[nums[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

### leetcode 1052  爱生气的书店老板

```c++
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        /*先计算有多少顾客，存入satisfy数组计算总和就是预期，然后用抑制技能看能挽回多少顾客，求挽回顾客的最大值*/
        int n = customers.size();
        vector<int> satisfy(n, 0);
        /*计算预期满意顾客数*/
        int total = 0;
        for (int i = 0; i < n; i++) {
            if (grumpy[i] == 0) {
                satisfy[i] = customers[i];
            } else {
                satisfy[i] = 0;
            }
            total += satisfy[i];
        }
        /*计算挽回的顾客的最大值*/
        int ans = 0;
        int cur = 0;
        for (int i = 0; i < minutes; i++) {
            if (satisfy[i] == 0) {
                cur += customers[i];
            }
        }
        ans = cur;
        /*遍历更新最大挽回顾客数*/
        for (int i = 1; i + minutes <= n; i++) {
            if (satisfy[i + minutes - 1] == 0 &&
                customers[i + minutes - 1] >= 0) {
                cur += customers[i + minutes - 1];
            }
            if (satisfy[i - 1] == 0 && customers[i - 1] >= 0) {
                cur -= customers[i - 1];
            }
            ans = max(cur, ans);
        }
        return ans + total;
    }
};
```

### leetcode 1100  长度为K的无重复字符子串

```c++
class Solution {
public:
    int numKLenSubstrNoRepeats(string s, int k) {
        /*最基本的滑动窗口*/
        int n = s.size();
        /*当字符串长度形成不了窗口返回0即可*/
        if (n < k) {
            return 0;
        }
        int ans = 0;
        int cur = 0;
        unordered_map<int, int> hash;
        for (int i = 0; i < k; i++) {
            hash[s[i]]++;
        }
        if (hash.size() == k) {
            ans++;
        }
        cur = ans;
        for (int i = 1; i + k <= n; i++) {
            /*左侧元素移除*/
            hash[s[i - 1]]--;
            if (hash[s[i - 1]] == 0) {
                hash.erase(s[i - 1]);
            }
            /*移入右侧元素*/
            hash[s[i + k - 1]]++;
            if (hash.size() == k) {
                ans++;
            }
        }
        return ans;
    }
};
```

### leetcode 1151  最少交换次数来组合所有的1

```c++
class Solution {
public:
    int minSwaps(vector<int>& data) {
        /*先计算data中1的个数，如果个数不超过1个返回0即可*/
        int num1 = 0;
        int n = data.size();
        for (int i = 0; i < n; i++) {
            if (data[i] == 1) {
                num1++;
            }
        }
        if (num1 <= 1) {
            return 0;
        }
        /*接下来就是计算长度num1的窗口滑动 最多能包住几个1*/
        int ans = 0;
        int cur = 0;
        for (int i = 0; i < num1; i++) {
            if (data[i] == 1) {
                ans++;
            }
        }
        cur = ans;
        for (int i = 1; i + num1 <= n; i++) {
            if (data[i - 1] == 1) {
                cur--;
            }
            if (data[i + num1 - 1] == 1) {
                cur++;
            }
            ans = max(cur, ans);
        }
        /*返回1的个数-最大窗口内1的个数*/
        return num1 - ans;
    }
};
```

### leetcode 1176 健身计划评估

```c++
class Solution {
public:
    int dietPlanPerformance(vector<int>& calories, int k, int lower,
                            int upper) {
        /*套模板即可*/
        int cur = 0;
        int ans = 0;
        int n = calories.size();
        for (int i = 0; i < k; i++) {
            cur += calories[i];
        }
        if (cur > upper) {
            ans++;
        } else if (cur < lower) {
            ans--;
        } else {
            ans = 0;
        }
        for (int i = 1; i + k <= n; i++) {
            cur += calories[i + k - 1] - calories[i - 1];
            if (cur > upper) {
                ans++;
            } else if (cur < lower) {
                ans--;
            }
        }
        return ans;
    }
};
```

### leetcode 1208  尽可能使字符串相等

```c++
class Solution {
public:
    int equalSubstring(string s, string t, int maxCost) {
        /*先判断是否有空字符串，有则直接返回0即可*/
        int m = s.size();
        int n = t.size();
        if (m == 0 || n == 0) {
            return 0;
        }
        int ans = 0;
        int left = 0;
        int right = 0;
        int curCost = 0;
        /*不定长滑动窗口，如果不符合条件直接移动左指针即可*/
        while (left <= right && right <= m - 1) {
            curCost += (abs(s[right] - t[right]));
            /*如果超预算就砍掉左边的字符*/
            while (curCost > maxCost) {
                curCost -= (abs(s[left] - t[left]));
                left++;
            }
            ans = max(ans, right - left + 1);
            right++;
        }
        return ans;
    }
};
```

### leetcode 1248  统计优美子数组

```c++
class Solution {
public:
    int numberOfSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        int left1 = 0;
        int left2 = 0;
        int sum1 = 0;
        int sum2 = 0;
        int ans = 0;
        for (int right = 0; right < n; right++) {
            /*维护2个窗口并更新答案*/
            sum1 += nums[right] & 1;
            while (left1 <= right && sum1 > k) {
                sum1 -= nums[left1] & 1;
                left1++;
            }
            sum2 += nums[right] & 1;
            while (left2 <= right && sum2 >= k) {
                sum2 -= nums[left2] & 1;
                left2++;
            }
            ans += left2 - left1;
        }
        return ans;
    }
};
```

### leetcode 1343  大小为 K 且平均值大于等于阈值的子数组数目

```c++
class Solution {
public:
    int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        int totalThreshold = k * threshold;
        int ans = 0;
        int cur = 0;
        int n = arr.size();
        /*获取初始值*/
        for (int i = 0; i < k; i++) {
            cur += arr[i];
        }
        /*判断是否符合条件，符合条件时则+1*/
        if (cur >= totalThreshold) {
            ans = 1;
        }
        for (int i = 1; i + k <= n; i++) {
            cur += (arr[i + k - 1] - arr[i - 1]);
            if (cur >= totalThreshold) {
                ans++;
            }
        }
        return ans;
    }
};
```

###  leetcode   1358  包含所有三种字符的子字符串数目

```c++
class Solution {
public:
    int numberOfSubstrings(string s) {
        /*越长越合法型滑动窗口*/
        int ans = 0;
        int left = 0;
        int n = s.size();
        unordered_map<int, int> hash;
        for (int right = 0; right < n; right++) {
            auto cur = s[right];
            hash[cur - 'a']++;
            /*收缩左边界*/
            while (hash[0] && hash[1] && hash[2]) {
                hash[s[left] - 'a']--;
                left++;
            }
            ans += left;
        }
        return ans;
    }
};
```

### leetcode 1423  可获得的最大点数

```c++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        /*逆转思维，每次取牌左右不固定，但是总和固定，可以转化为取n-k张牌的最小值*/
        int n = cardPoints.size();
        int ans = 0;
        int cur = 0;
        int total = 0;
        /*求总和*/
        for (int i = 0; i < n; i++) {
            total += cardPoints[i];
        }
        /*初始化值*/
        int window = n - k;
        /*如果n-k长度不为正则直接返回total即可*/
        if (window <= 0) {
            return total;
        }
        for (int i = 0; i < window; i++) {
            cur += cardPoints[i];
        }
        ans = cur;
        /*遍历更新最小值*/
        for (int i = 1; i + window <= n; i++) {
            cur += cardPoints[i+window-1]-cardPoints[i-1];
            ans = min(cur, ans);
        }
        return total - ans;
    }
};
```

### leetcode 1456  定长子串中元音的最大数目

```c++
class Solution {
    /*判断一个字母是否是元音字母*/
    bool isAEIOU(char c) {
        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {
            return true;
        } else {
            return false;
        }
    }

public:
    int maxVowels(string s, int k) {
        int n = s.size();
        int ans = 0;
        int cur = 0;
        /*先求出初始值*/
        for (int i = 0; i < k; i++) {
            if (isAEIOU(s[i])) {
                ans++;
            }
        }
        /*过渡初始值并求最大值*/
        cur = ans;
        for (int i = 1; i + k <= n; i++) {
            if (isAEIOU(s[i - 1])) {
                cur--;
            }
            if (isAEIOU(s[i + k - 1])) {
                cur++;
            }
            ans = max(cur, ans);
        }
        return ans;
    }
};
```

### leetcode 1493  删掉一个元素以后全为1的最长子数组

```c++
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        int left = 0;
        unordered_map<int, int> hash;
        for (int right = 0; right < n; right++) {
            auto cur = nums[right];
            hash[cur]++;
            while (hash[0] > 1) {
                hash[nums[left]]--;
                left++;
            }
            ans = max(ans, right - left);
        }
        return ans;
    }
};
```

### leetcode 1652 拆炸弹

```c++
class Solution {
public:
    vector<int> decrypt(vector<int>& code, int k) {
        int n = code.size();
        // 处理k=0的特殊情况
        if (k == 0) {
            return vector<int>(n, 0);
        }
        /*创建3倍长度的数组处理环形结构*/
        vector<int> newCode(3 * n);
        for (int i = 0; i < 3 * n; i++) {
            newCode[i] = code[i % n];
        }
        vector<int> ans(n);
        int len = abs(k);
        int left = 0;
        int right = 0;
        int windowSum = 0;
        if (k > 0) {
            left = n + 1;
            right = n + k;
        } else {
            left = n + k; 
            right = n - 1;
        }
        /*计算初始窗口和*/
        for (int i = left; i <= right; i++) {
            windowSum += newCode[i];
        }
        /*滑动窗口处理每个位置*/
        for (int i = n; i < 2 * n; i++) {
            ans[i - n] = windowSum;
            /*窗口滑动*/
            windowSum -= newCode[left];
            left++;
            right++;
            windowSum += newCode[right];
        }
        return ans;
    }
};
```

###  leetcode  1658  将X减到0的最小操作数

```c++
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        /*计算数组总和*/
        int total = accumulate(nums.begin(), nums.end(), 0);
        int target = total - x;
        int n = nums.size();
        if (target < 0) {
            return -1;
        }
        int left = 0;
        int curSum = 0;
        int ans = -1;
        for (int right = 0; right < n; right++) {
            /*拓展右边界，收缩左边界*/
            curSum += nums[right];
            while (curSum > target) {
                curSum -= nums[left];
                left++;
            }
            /*更新最大窗口长度*/
            if (curSum == target) {
                ans = max(ans, right - left + 1);
            }
        }
        return (ans != -1) ? n - ans : -1;
    }
};
```

### leetcode 1695  删除子数组的最大得分

```c++
class Solution {
public:
    int maximumUniqueSubarray(vector<int>& nums) {
        /*左右指针滑动，如果右指针摸到的元素和左指针相同，移动左指针*/
        int ans = 0;
        int left = 0;
        int n = nums.size();
        /*当前窗口元素和*/
        int currentSum = 0;
        unordered_map<int, int> hash;
        for (int right = 0; right < n; right++) {
            int cur = nums[right];
            currentSum += cur;
            /*如果新入元素已经存在，移除元素并从当前和中减去该元素值*/
            if (hash.find(cur) != hash.end() && hash[cur] >= left) {
                while (left <= hash[cur]) {
                    currentSum -= nums[left];
                    left++;
                }
            }
            /*更新元素最后出现的位置*/
            hash[cur] = right;
            ans = max(ans, currentSum);
        }
        return ans;
    }
};
```

### leetcode 1750 删除字符串两端相同字符后的最短长度

```c++
class Solution {
public:
    int minimumLength(string s) {
        int n = s.size();
        int left = 0;
        int right = n - 1;
        while (left < right && s[left] == s[right]) {
            char cur = s[left];
            /*跳过左侧连续相同字符*/
            while (left <= right && s[left] == cur) {
                left++;
            }
            /*跳过右侧连续相同字符*/
            while (left <= right && s[right] == cur) {
                right--;
            }
        }
        return right - left + 1;
    }
};
```

### leetcode 1852 每个子数组的数字种类数

```c++
class Solution {
public:
    vector<int> distinctNumbers(vector<int>& nums, int k) {
        /*基础滑动窗口题*/
        int n = nums.size();
        vector<int> ans(n - k + 1, 0);
        unordered_map<int, int> hash;
        /*长度为k的窗口从左往右滑动，统计hash表中元素即可*/
        for (int i = 0; i < k; i++) {
            hash[nums[i]]++;
        }
        ans[0] = hash.size();
        for (int i = 1; i + k <= n; i++) {
            /*移除左侧元素，加入右侧元素*/
            hash[nums[i - 1]]--;
            if (hash[nums[i - 1]] == 0) {
                hash.erase(nums[i - 1]);
            }
            hash[nums[i + k - 1]]++;
            ans[i] = hash.size();
        }
        return ans;
    }
};
```

### leetcode 1984  学生分数的最小差值

```c++
class Solution {
public:
    int minimumDifference(vector<int>& nums, int k) {
        if (k == 1) {
            return 0;
        }
        int n = nums.size();
        ranges::sort(nums);
        int ans = INT_MAX;
        /*滑动窗口遍历*/
        for (int i = 0; i < n - k + 1; ++i) {
            int diff = nums[i + k - 1] - nums[i];
            ans = min(ans, diff);
        }
        return ans;
    }
};
```

### leetcode 2024   考试的最大困扰度

```c++
class Solution {
public:
    int maxConsecutiveAnswers(string answerKey, int k) {
        int ans = 0;
        int left = 0;
        int n = answerKey.length();
        unordered_map<int, int> hash;
        for (int right = 0; right < n; right++) {
            /*使用位运算技巧将字符映射到索引*/
            int cur = answerKey[right] >> 1 & 1;
            hash[cur]++;
            /*当两种字符的数量都超过k时，需要缩小窗口*/
            while (hash[0] > k && hash[1] > k) {
                int leftIdx = answerKey[left] >> 1 & 1;
                hash[leftIdx]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

### leetcode 2090  半径为k的子数组平均值

```c++
class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k) {
        /*获取初始值，按照题意ans数组前后k个位置均为-1*/
        int n = nums.size();
        vector<int> ans(n, -1);
        long long sum = 0;
        int window = 2 * k + 1;
        if (window > n) {
            return ans;
        }
        for (int i = 0; i < window; i++) {
            sum += nums[i];
        }
        /*遍历有效中心*/
        for (int i = k; i + k < n; i++) {
            ans[i] = sum / window;
            /*防止最后一个中心位置越界*/
            if (i + k + 1 < n) {
                sum += nums[i + k + 1] - nums[i - k];
            }
        }
        return ans;
    }
};
```

### leetcode 2105   给植物浇水 II

```c++
class Solution {
public:
    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {
        int alice = capacityA;
        int bob = capacityB;
        int n = plants.size();
        int left = 0;
        int right = n - 1;
        int ans = 0;
        /*双指针遍历直到中间相遇*/
        while (left < right) {
            /*Alice需要重新装水*/
            if (alice < plants[left]) {
                alice = capacityA;
                ans++;
            }
            alice -= plants[left];
            left++;
            /*Bob需要重新装水*/
            if (bob < plants[right]) {
                bob = capacityB;
                ans++;
            }
            bob -= plants[right];
            right--;
        }
        /*处理中间剩一株植物的情况*/
        if (left == right && max(alice, bob) < plants[left]) {
            ans++;
        }
        return ans;
    }
};
```

### leetcode 2107  分享K个糖果后独特口味的数量

```c++
class Solution {
public:
    int shareCandies(vector<int>& candies, int k) {
        /*题意就是要滑动窗口，求哈希表内元素个数最大值*/
        int n = candies.size();
        unordered_map<int, int> hash;
        int ans = 0;
        int cur = 0;
        /*先将所有糖果味道加入哈希表*/
        for (int i = 0; i < n; i++) {
            hash[candies[i]]++;
        }
        /*初步给出糖果*/
        for (int i = 0; i < k; i++) {
            hash[candies[i]]--;
            if (hash[candies[i]] == 0) {
                hash.erase(candies[i]);
            }
        }
        ans = hash.size();
        cur = ans;
        /*求hash表中元素个数最大值*/
        for (int i = 1; i + k <= n; i++) {
            /*加入左侧元素到hash表*/
            hash[candies[i - 1]]++;
            /*移除右侧元素*/
            hash[candies[i + k - 1]]--;
            if (hash[candies[i + k - 1]] == 0) {
                hash.erase(candies[i + k - 1]);
            }
            cur = hash.size();
            ans = max(cur, ans);
        }
        return ans;
    }
};
```

### leetcode 2134  最少交换次数来组合所有的 1 II

```c++
class Solution {
public:
    int minSwaps(vector<int>& nums) {
        /*环形数组要使用最少次数聚合所有1，可以复制2n长度数组，然后找答案*/
        int n = nums.size();
        int num1 = 0;
        /*统计1的个数*/
        for (int i = 0; i < n; i++) {
            if (nums[i] == 1) {
                num1++;
            }
        }
        /*特殊情况处理*/
        if (num1 == 0 || num1 == n) {
            return 0;
        }
        /*创建新数组找最少交换次数*/
        vector<int> doubleNums(2 * n);
        int N = 2 * n;
        for (int i = 0; i < N; i++) {
            doubleNums[i] = nums[i % n];
        }
        int ans = INT_MAX;
        int cur = 0;
        for (int i = 0; i < num1; i++) {
            if (doubleNums[i] == 0) {
                cur++;
            }
        }
        ans = cur;
        for (int i = 1; i < n; i++) {
            if (doubleNums[i - 1] == 0) {
                cur--;
            }
            if (doubleNums[i + num1 - 1] == 0) {
                cur++;
            }
            ans = min(cur, ans);
        }
        return ans;
    }
};
```

### leetcode 2302  统计得分小于K的子数组数目

```c++
class Solution {
public:
    long long countSubarrays(vector<int>& nums, long long k) {
        long long cur = 0;
        long long ans = 0;
        int left = 0;
        int n = nums.size();
        /*滑动窗口*/
        for (int right = 0; right < n; right++) {
            cur += nums[right];
            /*检查当前子数组的和乘以长度是否满足条件*/
            while (cur * (right - left + 1) >= k) {
                cur -= nums[left];
                left++;
            }
            ans += right - left + 1;
        }
        return ans;
    }
};
```

### leetcode 2379  得到 K 个黑块的最少涂色次数

```c++
class Solution {
public:
    int minimumRecolors(string blocks, int k) {
        /*获取初始值并不断更新，把初始值设为最大*/
        int ans = INT_MAX;
        int cur = 0;
        int n = blocks.size();
        for (int i = 0; i < k; i++) {
            if (blocks[i] == 'W')
                cur++;
        }
        ans = min(ans, cur);
        for (int i = 1; i + k <= n; i++) {
            if (blocks[i - 1] == 'W') {
                cur--;
            }
            if (blocks[i + k - 1] == 'W') {
                cur++;
            }
            ans = min(ans, cur);
        }
        return ans;
    }
};
```

### leetcode 2461  长度为K子数组中的最大和

```c++
class Solution {
public:
    long long maximumSubarraySum(vector<int>& nums, int k) {
        long long ans = 0;
        long long cur = 0;
        unordered_map<int, int> hash;
        int n = nums.size();
        for (int i = 0; i < k; i++) {
            cur += nums[i];
            hash[nums[i]]++;
        }
        /*检查初始化的hash表是否符合条件*/
        if (hash.size() == k) {
            ans = cur;
        }
        for (int i = 1; i + k <= n; i++) {
            /*移除左侧元素*/
            hash[nums[i - 1]]--;
            if (hash[nums[i - 1]] == 0) {
                hash.erase(nums[i - 1]);
            }
            /*添加右侧元素*/
            hash[nums[i + k - 1]]++;
            cur += (nums[i + k - 1] - nums[i - 1]);
            /*检查条件并更新答案*/
            if (hash.size() == k) {
                ans = max(ans, cur);
            }
        }
        return ans;
    }
};
```

### leetcode  2730   找到最长的半重复子字符串

```c++
class Solution {
public:
    int longestSemiRepetitiveSubstring(string s) {
        int left = 0;
        int n = s.size();
        int same = 0;
        int ans = 1;
        /*滑动窗口，如果出现same大于1就缩窗，出现左指针前后2个不相同继续缩窗*/
        for (int right = 1; right < n; right++) {
            if (s[right] == s[right - 1]) {
                same++;
            }
            if (same > 1) {
                left++;
                while (s[left] != s[left - 1]) {
                    left++;
                }
                same = 1;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

### leetcode 2824  统计和小于目标的下标对数目

```c++
class Solution {
public:
    int countPairs(vector<int>& nums, int target) {
        /*数组元素排序*/
        ranges::sort(nums);
        int ans = 0;
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        /*相向双指针遍历*/
        while (left < right) {
            auto sum = nums[left] + nums[right];
            /*如果当前双指针符合条件该区间都符合条件，反之缩窗*/
            if (sum < target) {
                ans += right - left;
                left++;
            } else {
                right--;
            }
        }
        return ans;
    }
};
```

### leetcode 2841  几乎唯一子数组的最大和

```c++
class Solution {
public:
    long long maxSum(vector<int>& nums, int m, int k) {
        long long ans = 0;
        long long cur = 0;
        unordered_map<int, int> hash;
        int n = nums.size();
        for (int i = 0; i < k; i++) {
            cur += nums[i];
            hash[nums[i]]++;
        }
        /*检查初始化的hash表是否符合条件*/
        if (hash.size() >= m) {
            ans = cur;
        }
        for (int i = 1; i + k <= n; i++) {
            /*移除左侧元素*/
            hash[nums[i - 1]]--;
            if (hash[nums[i - 1]] == 0) {
                hash.erase(nums[i - 1]);
            }
            /*添加右侧元素*/
            hash[nums[i + k - 1]]++;
            cur += (nums[i + k - 1] - nums[i - 1]);
            /*检查条件并更新答案*/
            if (hash.size() >= m) {
                ans = max(ans, cur);
            }
        }
        return ans;
    }
};
```

### leetcode   2958  最多 K 个重复元素的最长子数组

```c++
class Solution {
public:
    int maxSubarrayLength(vector<int>& nums, int k) {
        int ans = 0;
        int left = 0;
        unordered_map<int, int> cnt;
        /*遍历数组*/
        for (int right = 0; right < nums.size(); right++) {
            cnt[nums[right]]++;
            /*当前数字的出现次数超过k时*/
            while (cnt[nums[right]] > k) {
                cnt[nums[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

###  leetcode  2962  统计最大元素出现至少K次的子数组

```c++
/*模板解法*/
class Solution {
public:
    long long countSubarrays(vector<int>& nums, int k) {
        long long ans = 0;
        int left = 0;
        int n = nums.size();
        unordered_map<int, int> hash;
        int curMaxNum = 0;
        int maxNum = ranges::max(nums);
        for (int right = 0; right < n; right++) {
            auto cur = nums[right];
            hash[cur]++;
            while (hash[maxNum] == k) {
                hash[nums[left]]--;
                left++;
            }
            ans += left;
        }
        return ans;
    }
};
/*优化解法*/
class Solution {
public:
    long long countSubarrays(vector<int>& nums, int k) {
        int maxNum = ranges::max(nums);
        long long ans = 0;
        int cnt_maxNum = 0;
        int left = 0;
        int n = nums.size();
        /*遍历数组中的每个元素作为右边界*/
        for (int right = 0; right < n; right++) {
            auto x = nums[right];
            /*如果当前元素是最大值，则计数器加1*/
            if (x == maxNum) {
                cnt_maxNum++;
            }
            while (cnt_maxNum == k) {
                /*移动左指针，并检查是否是最大值*/
                if (nums[left] == maxNum) {
                    cnt_maxNum--;
                }
                left++;
            }
            /*left指向第一个不满足条件的位置*/
            ans += left;
        }
        return ans;
    }
};
```

### leetcode 3090  每个字符最多出现两次的最长子字符串

```c++
class Solution {
public:
    int maximumLengthSubstring(string s) {
        int n = s.size();
        int left = 0;
        int ans = 0;
        unordered_map<int, int> hash;
        /*使用哈希表，频率大于2就缩小窗口*/
        for (int right = 0; right < n; right++) {
            auto cur = s[right];
            hash[cur]++;
            while (hash[cur] > 2) {
                hash[s[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

### leetcode 3258  统计满足 K 约束的子字符串数量 I

```c++
class Solution {
public:
    int countKConstraintSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;
        int left = 0;
        unordered_map<char, int> hash;
        /*右指针遍历所有字符*/
        for (int right = 0; right < n; right++) {
            auto cur = s[right];
            hash[cur]++;
            /*收缩窗口*/
            while (hash['0'] > k && hash['1'] > k) {
                hash[s[left]]--;
                left++;
            }
            ans += right - left + 1;
        }
        return ans;
    }
};
```

### leetcode 3325   字符至少出现 K 次的子字符串 I

```c++
class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;
        int left = 0;
        unordered_map<int, int> hash;
        int conditionNum = 0;
        for (int right = 0; right < n; right++) {
            auto cur = s[right];
            hash[cur]++;
            if (hash[cur] >= k) {
                conditionNum++;
            }
            /*满足条件时候收缩窗口*/
            while (conditionNum) {
                hash[s[left]]--;
                if (hash[s[left]] == k - 1) {
                    conditionNum--;
                }
                left++;
            }
            ans += left;
        }
        return ans;
    }
};
```

### leetcode 3439  重新安排会议得到最多空余时间 I

```c++
class Solution {
public:
    int maxFreeTime(int eventTime, int k, vector<int>& startTime,
                    vector<int>& endTime) {
        /*构建空闲时间段数*/
        int n = startTime.size();
        vector<int> free(n + 1);
        free[0] = startTime[0];
        for (int i = 1; i < n; i++) {
            free[i] = startTime[i] - endTime[i - 1];
        }
        free[n] = eventTime - endTime[n - 1];
        /*滑动窗口求最大连续空闲和*/
        int ans = 0;
        int cur = 0;
        for (int i = 0; i <= n; i++) {
            cur += free[i];
            /*如果当前安排的会议数不到目标数继续安排会议*/
            if (i < k) {
                continue;
            }
            ans = max(ans, cur);
            cur -= free[i - k];
        }
        return ans;
    }
};
```

