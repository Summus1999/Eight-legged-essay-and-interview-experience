# 矩阵

### leetcode 73 矩阵置零

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int> row(m);
        vector<int> col(n);
        /*将0所在行列标记为true*/
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    row[i] = true;
                    col[j] = true;
                }
            }
        }
        /*遍历，被标记的行列所在元素置为0*/
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (row[i] == 1 || col[j] == 1) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
};
```

### leetcode 54 螺旋矩阵

```c++
class Solution {
    static constexpr int DIRS[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int> ans(m * n);
        int i = 0;
        int j = 0;
        int di = 0;
        for (int k = 0; k < m * n; k++) {
            /*标记当前位置已访问*/
            ans[k] = matrix[i][j];
            /*计算按当前方向的下一个位置*/
            matrix[i][j] = INT_MAX;
            int x = i + DIRS[di][0];
            int y = j + DIRS[di][1];
            /*检查是否需要改变方向（越界或已访问）*/
            if (x < 0 || y < 0 || x >= m || y >= n || matrix[x][y] == INT_MAX) {
                di = (di + 1) % 4;
            }
            /*移动到下一个位置*/
            i += DIRS[di][0];
            j += DIRS[di][1];
        }
        return ans;
    }
};
```

### leetcode 48 旋转图像

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        /*转置*/
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < i; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        /*后翻转*/
        for (auto& row : matrix) {
            ranges::reverse(row);
        }
    }
};
```

### leetcode 240  搜索二维矩阵 II

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m=matrix.size();
        int n=matrix[0].size();
        int i=0;
        int j=n-1;
        while(i<m&&j>=0){
            /*如果右上角元素为target直接输出*/
            if(matrix[i][j]==target){
                return true;
            }else if(matrix[i][j]<target){
                /*本行所有数小于target，搜下一行*/
                i++;
            }else if(matrix[i][j]>target){
                /*本列所有数大于target，搜下一列*/
                j--;
            }
        }
        return false;
    }
};
```

### leetcode X

```c++

```

### leetcode X

```c++
```

